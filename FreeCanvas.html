<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Interactive Wall Painter ¬∑ Empty Shapes, Compact & Centered</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700;800&display=swap" rel="stylesheet">
  <style>
    :root{
      --glass: rgba(255,255,255,0.06);
      --glass-2: rgba(255,255,255,0.04);
      --accent-a: #7c3aed;
      --accent-b: #06b6d4;
      --toolbar-glow: rgba(124,58,237,0.25);
    }
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: radial-gradient(1200px 600px at 10% 10%, rgba(124,58,237,0.08), transparent), linear-gradient(180deg,#07070a 0%, #0f1724 100%);
      touch-action: none;
      font-family: 'Space Grotesk', Arial, sans-serif;
      color: #ecf2ff;
    }
    canvas {
      display: block;
      background: #fff;
      width: 100vw;
      height: 100vh;
      cursor: crosshair;
    }

    /* ---------- COMPACT CENTERED TOOLBAR ---------- 
       - smaller buttons (64px), reduced gap & padding
       - vertically centered on the right side
       - 2 columns, compact
    */
    .toolbar-grid {
      position: fixed;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      display: grid;
      grid-template-columns: repeat(2, 64px);
      gap: 12px;
      padding: 20px 16px;
      border-radius: 28px;
      background: rgba(10, 15, 30, 0.75);
      backdrop-filter: blur(20px) saturate(200%);
      box-shadow: 0 20px 35px rgba(2,6,23,0.9);
      z-index: 1200;
      border: 1px solid rgba(255,255,255,0.12);
      max-width: 180px;
    }

    .toolbar-grid button {
      width: 64px;
      height: 64px;
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(16, 22, 40, 0.7);
      color: rgba(255,255,255,0.92);
      border: 1px solid rgba(255,255,255,0.1);
      cursor: pointer;
      font-weight: 700;
      transition: transform .16s ease, box-shadow .2s ease, background .18s ease;
      -webkit-tap-highlight-color: transparent;
      backdrop-filter: blur(10px);
      padding: 0;
      position: relative;
    }

    .toolbar-grid button:hover {
      transform: translateY(-4px);
      box-shadow: 0 12px 20px rgba(0,0,0,0.6);
      background: rgba(32, 42, 68, 0.85);
      color: #fff;
    }

    .toolbar-grid button svg {
      width: 28px;
      height: 28px;
      stroke: currentColor;
      fill: none;
      stroke-width: 1.8;
    }

    .toolbar-grid button.active {
      background: linear-gradient(145deg, var(--accent-a), var(--accent-b));
      box-shadow: 0 12px 22px var(--toolbar-glow);
      border-color: rgba(255,255,255,0.4);
      transform: translateY(-4px);
      color: #fff;
    }

    /* tooltip labels ‚Äì left side (since toolbar on right) */
    @media(min-width:760px){
      .toolbar-grid button .label {
        display: block;
        position: absolute;
        right: 80px;
        background: rgba(8, 16, 36, 0.95);
        padding: 7px 16px;
        border-radius: 30px;
        font-weight: 600;
        font-size: 13px;
        color: #fff;
        white-space: nowrap;
        opacity: 0;
        transform: translateX(-8px);
        transition: opacity .14s, transform .14s;
        backdrop-filter: blur(6px);
        border: 1px solid rgba(255,255,255,0.14);
        letter-spacing: 0.4px;
        box-shadow: 0 8px 16px rgba(0,0,0,0.5);
        pointer-events: none;
        z-index: 1300;
      }
      .toolbar-grid button:hover .label {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* category headers */
    .toolbar-grid .tool-category {
      grid-column: span 2;
      color: rgba(210, 230, 255, 0.6);
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 2px;
      text-transform: uppercase;
      margin-top: 6px;
      margin-bottom: 0px;
      padding-left: 6px;
      padding-bottom: 8px;
      border-bottom: 1.5px solid rgba(255,255,255,0.12);
    }

    /* Back button */
    .back-button {
      position: fixed;
      left: 24px;
      bottom: 24px;
      background: linear-gradient(145deg,#ef4444,#f97316);
      color: #fff;
      border: none;
      padding: 12px 24px;
      border-radius: 50px;
      cursor: pointer;
      font-size: 15px;
      z-index: 1200;
      transition: transform .16s ease, box-shadow .2s ease;
      box-shadow: 0 14px 24px rgba(239,68,68,0.25);
      font-weight: 700;
      border: 1px solid rgba(255,255,255,0.2);
      backdrop-filter: blur(8px);
      display: flex;
      align-items: center;
      gap: 8px;
      letter-spacing: 0.8px;
    }
    .back-button:hover{ transform: translateY(-4px); background: linear-gradient(145deg,#dc2626,#ea580c); }

    canvas {
      background: #fff;
    }

    /* clear button spans both columns */
    button[data-brush="clear-canvas"] {
      grid-column: span 2;
      width: auto;
      background: rgba(220, 38, 38, 0.7);
      border-color: rgba(255,100,100,0.3);
      height: 56px;
      margin-top: 4px;
    }
    button[data-brush="clear-canvas"] svg {
      width: 26px;
      height: 26px;
    }
    button[data-brush="clear-canvas"] .label {
      right: auto;
      left: -130px;
    }
  </style>
</head>
<body>

<!-- COMPACT CENTERED TOOLBAR (RIGHT SIDE) -->
<div class="toolbar-grid">

  <!-- BRUSHES category -->
  <div class="tool-category">‚úèÔ∏è BRUSH</div>

  <button data-brush="pen" class="active" title="Pen" aria-label="Pen brush">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M3 21v-3l11-11 3 3L6 21H3z"/><path d="M14 7l3 3"/></svg>
    <span class="label">Pen</span>
  </button>
  <button data-brush="soft" title="Soft" aria-label="Soft brush">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M2 12c2-4 8-6 12-6 3 0 6 1 8 4v6a2 2 0 0 1-2 2c-3 0-6-1-8-3-4-3-8-3-10-3z"/><path d="M7 17c0 1.5 2.5 3 5 3s5-1.5 5-3"/></svg>
    <span class="label">Soft</span>
  </button>
  <button data-brush="marker" title="Marker" aria-label="Marker brush">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M2 12l6 6 10-10-6-6L2 12z"/><path d="M7 17l-3 3"/></svg>
    <span class="label">Marker</span>
  </button>
  <button data-brush="spray" title="Spray" aria-label="Spray">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><rect x="3" y="3" width="18" height="6" rx="1"/><path d="M7 21a4 4 0 0 1 8 0"/><path d="M12 9v2"/><circle cx="17" cy="17" r="1"/><circle cx="19" cy="14" r="1"/><circle cx="14" cy="19" r="1"/></svg>
    <span class="label">Spray</span>
  </button>
  <button data-brush="ink" title="Ink" aria-label="Ink">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M12 2s4 4 4 7a4 4 0 0 1-8 0c0-3 4-7 4-7z"/><path d="M8 21h8"/></svg>
    <span class="label">Ink</span>
  </button>
  <!-- ERASER -->
  <button data-brush="eraser" title="Eraser" aria-label="Eraser">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M18 6L6 18"/><path d="M8 4L4 8"/><path d="M20 16L16 20"/><rect x="6.5" y="6.5" width="11" height="11" rx="1"/></svg>
    <span class="label">Eraser</span>
  </button>
  <span></span> <!-- grid filler -->

  <!-- SHAPES CATEGORY -->
  <div class="tool-category">üî∫ SHAPES</div>

  <button data-brush="shape-rect" title="Rectangle" aria-label="Draw rectangle">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><rect x="4" y="4" width="16" height="16" rx="2"/></svg>
    <span class="label">Rectangle</span>
  </button>
  <button data-brush="shape-circle" title="Circle" aria-label="Draw circle">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><circle cx="12" cy="12" r="8"/></svg>
    <span class="label">Circle</span>
  </button>
  <button data-brush="shape-line" title="Line" aria-label="Draw straight line">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.8" fill="none"><path d="M5 19L19 5"/></svg>
    <span class="label">Line</span>
  </button>
  <button data-brush="shape-triangle" title="Triangle" aria-label="Draw triangle">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.6" fill="none"><path d="M12 4L4 20h16L12 4z"/></svg>
    <span class="label">Triangle</span>
  </button>
  
  <!-- filler cells -->
  <span></span><span></span>

  <!-- CLEAR CANVAS BUTTON -->
  <div class="tool-category" style="border-bottom: none; margin-top: 12px;">üóëÔ∏è ACTIONS</div>
  <button data-brush="clear-canvas" title="Clear Canvas" aria-label="Clear entire canvas">
    <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.8" fill="none">
      <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/>
      <path d="M10 11v5M14 11v5"/>
    </svg>
    <span class="label" style="right: auto; left: -140px;">Clear Canvas</span>
  </button>
</div>

<!-- Back button -->
<button class="back-button" onclick="window.location.href='index.html'">‚Üê Back</button>

<canvas id="canvas"></canvas>

<script>
  (function() {
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    let currentBrush = "pen";
    const pointers = new Map();
    const shapePoints = new Map();

    // UI: toolbar button activation (with clear canvas special case)
    const toolbarButtons = document.querySelectorAll(".toolbar-grid button");
    toolbarButtons.forEach(btn => {
      btn.onclick = (e) => {
        if (btn.dataset.brush === "clear-canvas") {
          clearCanvas();
          return;
        }
        toolbarButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        currentBrush = btn.dataset.brush;
      };
    });

    function randomColor() {
      return `hsl(${Math.random() * 360}, 80%, 60%)`;
    }

    function clearCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      // reset preview buffer if any
      window.previewCaptured = false;
      window.previewBuffer = null;
    }

    function resizeCanvas() {
      const w = window.innerWidth;
      const h = window.innerHeight;
      const prevCanvas = document.createElement('canvas');
      if (canvas.width && canvas.height) {
        prevCanvas.width = canvas.width;
        prevCanvas.height = canvas.height;
        prevCanvas.getContext('2d').drawImage(canvas, 0, 0);
      }
      canvas.width = w;
      canvas.height = h;
      if (prevCanvas.width) {
        ctx.drawImage(prevCanvas, 0, 0, prevCanvas.width, prevCanvas.height, 0, 0, w, h);
      }
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
    }

    canvas.addEventListener("contextmenu", (e) => e.preventDefault());

    // ----- POINTER DOWN -----
    canvas.addEventListener("pointerdown", e => {
      canvas.setPointerCapture(e.pointerId);
      const color = randomColor();

      pointers.set(e.pointerId, {
        x: e.clientX,
        y: e.clientY,
        color: color
      });

      if (currentBrush.startsWith("shape-")) {
        shapePoints.set(e.pointerId, {
          startX: e.clientX,
          startY: e.clientY,
          color: color
        });
        // Reset preview buffer for new shape
        window.previewCaptured = false;
        window.previewBuffer = null;
      }
    });

    // ----- POINTER MOVE (free drawing, eraser, LIVE SHAPE PREVIEW) -----
    canvas.addEventListener("pointermove", e => {
      if (!pointers.has(e.pointerId)) return;
      const p = pointers.get(e.pointerId);

      // Free drawing brushes
      if (!currentBrush.startsWith("shape-") && currentBrush !== "eraser") {
        drawBrush(p, e.clientX, e.clientY);
        p.x = e.clientX;
        p.y = e.clientY;
      }
      
      // ERASER
      if (currentBrush === "eraser") {
        ctx.globalAlpha = 1;
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 26;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(e.clientX, e.clientY);
        ctx.stroke();
        p.x = e.clientX;
        p.y = e.clientY;
      }

      // ----- LIVE SHAPE PREVIEW (dashed, NO FILL - EMPTY) -----
      if (currentBrush.startsWith("shape-") && shapePoints.has(e.pointerId)) {
        // Capture canvas state before first preview
        if (!window.previewCaptured) {
          window.previewBuffer = document.createElement('canvas');
          window.previewBuffer.width = canvas.width;
          window.previewBuffer.height = canvas.height;
          window.previewBuffer.getContext('2d').drawImage(canvas, 0, 0);
          window.previewCaptured = true;
        }
        
        // Restore canvas from buffer (removes previous preview)
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.drawImage(window.previewBuffer, 0, 0);
        
        // Draw live shape preview (dashed, NO FILL)
        const s = shapePoints.get(e.pointerId);
        const startX = s.startX, startY = s.startY;
        const endX = e.clientX, endY = e.clientY;
        const shapeColor = s.color;

        ctx.save();
        ctx.strokeStyle = shapeColor;
        ctx.fillStyle = "transparent"; // üö´ NO FILL ‚Äì empty interior
        ctx.lineWidth = 4;
        ctx.setLineDash([5, 5]); // dashed preview
        ctx.lineDashOffset = 2;

        if (currentBrush === "shape-rect") {
          const w = endX - startX;
          const h = endY - startY;
          ctx.fillRect(startX, startY, w, h); // fill transparent does nothing
          ctx.strokeRect(startX, startY, w, h);
        }
        else if (currentBrush === "shape-circle") {
          const radius = Math.hypot(endX - startX, endY - startY);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
          ctx.fill(); // transparent fill
          ctx.stroke();
        }
        else if (currentBrush === "shape-line") {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = shapeColor;
          ctx.lineWidth = 5;
          ctx.stroke(); // line has no fill
        }
        else if (currentBrush === "shape-triangle") {
          const dx = endX - startX;
          const dy = endY - startY;
          const perpX = -dy * 0.35;
          const perpY = dx * 0.35;
          ctx.beginPath();
          ctx.moveTo(startX + perpX, startY + perpY);
          ctx.lineTo(endX, endY);
          ctx.lineTo(startX - perpX, startY - perpY);
          ctx.closePath();
          ctx.fill(); // transparent
          ctx.stroke();
        }
        ctx.restore();
      }
    });

    // ----- POINTER UP (finalize shape, NO FILL - EMPTY) -----
    canvas.addEventListener("pointerup", e => {
      if (shapePoints.has(e.pointerId) && currentBrush.startsWith("shape-")) {
        const s = shapePoints.get(e.pointerId);
        const startX = s.startX, startY = s.startY;
        const endX = e.clientX, endY = e.clientY;
        const shapeColor = s.color;

        // Restore clean canvas from buffer (remove preview)
        if (window.previewBuffer) {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(window.previewBuffer, 0, 0);
        }

        // Draw final solid shape ‚Äì WITHOUT FILL (empty)
        ctx.save();
        ctx.strokeStyle = shapeColor;
        ctx.fillStyle = "transparent"; // üö´ NO FILL ‚Äì completely empty
        ctx.lineWidth = 4.2;
        ctx.setLineDash([]); // solid line

        if (currentBrush === "shape-rect") {
          const w = endX - startX;
          const h = endY - startY;
          ctx.fillRect(startX, startY, w, h); // transparent fill
          ctx.strokeRect(startX, startY, w, h);
        }
        else if (currentBrush === "shape-circle") {
          const radius = Math.hypot(endX - startX, endY - startY);
          ctx.beginPath();
          ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
          ctx.fill(); // transparent
          ctx.stroke();
        }
        else if (currentBrush === "shape-line") {
          ctx.beginPath();
          ctx.moveTo(startX, startY);
          ctx.lineTo(endX, endY);
          ctx.strokeStyle = shapeColor;
          ctx.lineWidth = 5;
          ctx.stroke(); // no fill
        }
        else if (currentBrush === "shape-triangle") {
          const dx = endX - startX;
          const dy = endY - startY;
          const perpX = -dy * 0.35;
          const perpY = dx * 0.35;
          ctx.beginPath();
          ctx.moveTo(startX + perpX, startY + perpY);
          ctx.lineTo(endX, endY);
          ctx.lineTo(startX - perpX, startY - perpY);
          ctx.closePath();
          ctx.fill(); // transparent
          ctx.stroke();
        }
        ctx.restore();

        // Update buffer to include final shape
        if (window.previewBuffer) {
          window.previewBuffer.width = canvas.width;
          window.previewBuffer.height = canvas.height;
          window.previewBuffer.getContext('2d').drawImage(canvas, 0, 0);
        }
        shapePoints.delete(e.pointerId);
      }

      pointers.delete(e.pointerId);
      shapePoints.delete(e.pointerId);
      window.previewCaptured = false;
      window.previewBuffer = null;
    });

    canvas.addEventListener("pointercancel", stop);
    canvas.addEventListener("pointerout", stop);
    function stop(e) {
      pointers.delete(e.pointerId);
      shapePoints.delete(e.pointerId);
      window.previewCaptured = false;
      window.previewBuffer = null;
    }

    // Brush implementations
    function drawBrush(p, x, y) {
      ctx.strokeStyle = p.color;
      switch (currentBrush) {
        case "pen":
          ctx.globalAlpha = 1;
          ctx.lineWidth = 4.5;
          drawLine(p, x, y);
          break;
        case "soft":
          ctx.globalAlpha = 0.2;
          ctx.lineWidth = 24;
          drawLine(p, x, y);
          break;
        case "marker":
          ctx.globalAlpha = 0.8;
          ctx.lineWidth = 13;
          drawLine(p, x, y);
          break;
        case "spray":
          spray(p, x, y);
          break;
        case "ink":
          ctx.globalAlpha = 0.85;
          ctx.lineWidth = 3 + Math.random() * 8;
          drawLine(p, x, y);
          break;
        default: break;
      }
      ctx.globalAlpha = 1;
    }

    function drawLine(p, x, y) {
      ctx.beginPath();
      ctx.moveTo(p.x, p.y);
      ctx.lineTo(x, y);
      ctx.stroke();
    }

    function spray(p, x, y) {
      ctx.fillStyle = p.color;
      for (let i = 0; i < 30; i++) {
        const offsetX = (Math.random() - 0.5) * 40;
        const offsetY = (Math.random() - 0.5) * 40;
        ctx.fillRect(x + offsetX, y + offsetY, 2, 2);
      }
    }

    window.onload = ()=>{
      ctx.clearRect(0,0,canvas.width,canvas.height);
      window.previewCaptured = false;
      window.previewBuffer = null;
    };
  })();
</script>

<!-- Responsive fine-tuning -->
<style>
  @media (max-width: 700px) {
    .toolbar-grid {
      right: 12px;
      grid-template-columns: repeat(2, 58px);
      gap: 10px;
      padding: 16px 12px;
    }
    .toolbar-grid button {
      width: 58px;
      height: 58px;
    }
    .toolbar-grid button svg {
      width: 24px;
      height: 24px;
    }
    button[data-brush="clear-canvas"] {
      height: 50px;
    }
  }
</style>
</body>
</html>
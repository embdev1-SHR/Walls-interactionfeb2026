<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Fish Catcher – Koi Pond</title>
    <style>
        * {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0b1d1e; /* Deep pond color */
            color: white;
            height: 100vh;
            width: 100vw;
            position: relative;
            touch-action: none;
        }

        /* ===== UI – SCORE ===== */
        .game-ui {
            position: absolute;
            top: 30px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: center;
            pointer-events: none;
            z-index: 100;
        }
        .stat-item {
            background: rgba(11, 29, 30, 0.7);
            backdrop-filter: blur(8px);
            padding: 12px 40px;
            border-radius: 50px;
            border: 2px solid rgba(135, 206, 235, 0.3);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .stat-label {
            font-size: 14px;
            font-weight: 700;
            color: rgba(135, 206, 235, 0.8);
            text-transform: uppercase;
            letter-spacing: 2px;
            margin-bottom: 5px;
        }
        .stat-value {
            font-size: 48px;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5);
            line-height: 1;
        }

        /* ===== BACK BUTTON (EXACTLY AS PRESERVED) ===== */
        .back-btn-container {
            position: absolute;
            top: 260px;
            left: 30px;
            z-index: 150;
            pointer-events: auto;
        }
        .back-button {
            background: rgba(2, 136, 209, 0.7);
            backdrop-filter: blur(12px);
            border: 3px solid #4fc3f7;
            border-radius: 60px;
            padding: 16px 36px;
            display: flex;
            align-items: center;
            gap: 16px;
            color: white;
            font-size: 28px;
            font-weight: 800;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: 0.2s;
            letter-spacing: 2px;
        }
        .back-button i {
            font-size: 36px;
            color: white;
        }
        .back-button:active {
            transform: scale(0.92);
            background: rgba(2, 136, 209, 0.9);
        }

        /* Start Screen */
        .start-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: radial-gradient(circle at center, rgba(16, 46, 51, 0.95), #050f10);
            z-index: 200;
            pointer-events: auto;
        }
        .start-title {
            font-family: 'Brush Script MT', 'Segoe UI', serif; /* stylized font */
            font-size: 80px;
            font-weight: 400;
            color: #ff7e67;
            text-shadow: 4px 4px 0px rgba(0,0,0,0.5);
            margin-bottom: 10px;
        }
        .start-subtitle {
            font-size: 18px;
            color: #a0c4c4;
            margin-bottom: 50px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }
        .start-btn {
            padding: 20px 60px;
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #ff7e67, #e55b44);
            color: white;
            border: none;
            border-radius: 100px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(229, 91, 68, 0.4);
            transition: transform 0.2s;
            border: 2px solid rgba(255,255,255,0.2);
        }
        .start-btn:hover { transform: scale(1.05); }

        /* Game Over Screen */
        .game-over {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(11, 29, 30, 0.95);
            padding: 50px;
            border-radius: 30px;
            text-align: center;
            border: 2px solid #547c7e;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8);
            display: none;
            z-index: 300;
            min-width: 400px;
        }
        .game-over.show { display: block; animation: popIn 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); }
        @keyframes popIn { from { transform: translate(-50%, -60%) scale(0.9); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
        
        .go-btn {
            margin: 10px;
            padding: 15px 40px;
            font-size: 18px;
            font-weight: 700;
            background: transparent;
            color: white;
            border: 2px solid white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .go-btn:hover { background: white; color: #0b1d1e; }

        /* Game Area */
        #fishCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 5;
        }

        /* Points Animation */
        .points-display {
            position: absolute;
            font-size: 32px;
            font-weight: 900;
            color: #ffcf40;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            pointer-events: none;
            z-index: 100;
            animation: pointsFloat 0.8s ease-out forwards;
        }
        @keyframes pointsFloat {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-50px) scale(1.2); }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>

    <canvas id="fishCanvas"></canvas>
    
    <div class="start-screen" id="startScreen">
        <h1 class="start-title">Koi Pond</h1>
        <p class="start-subtitle">Relax &bullet; Catch &bullet; Enjoy</p>
        <button class="start-btn" id="startBtn">ENTER POND</button>
    </div>
    
    <div class="game-ui">
        <div class="stat-item">
            <div class="stat-label">Collection</div>
            <div class="stat-value" id="scoreDisplay">0</div>
        </div>
    </div>
    
    <div class="back-btn-container">
        <div class="back-button" id="global-back">
            <i class="fas fa-arrow-left"></i> BACK
        </div>
    </div>
    
    <div class="game-over" id="gameOver">
        <h1 style="color: #ff7e67; margin-bottom: 10px;">Serene Catch</h1>
        <div style="font-size: 48px; font-weight: 800; margin-bottom: 20px; color: #fff;" id="finalScore">0</div>
        <div style="color: #888; margin-bottom: 30px;" id="highScore">Best: 0</div>
        <div>
            <button class="go-btn" id="playAgainBtn">CONTINUE</button>
            <button class="go-btn" id="menuBtn">EXIT</button>
        </div>
    </div>

    <script>
        "use strict";

        // ==================== VECTOR2 ====================
        class Vector2 {
            constructor(x, y) { this.x = x; this.y = y; }
            add(v) { return new Vector2(this.x + v.x, this.y + v.y); }
            sub(v) { return new Vector2(this.x - v.x, this.y - v.y); }
            mult(n) { return new Vector2(this.x * n, this.y * n); }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                const m = this.mag();
                return m !== 0 ? this.mult(1 / m) : new Vector2(0, 0);
            }
            setMag(n) { return this.normalize().mult(n); }
            heading() { return Math.atan2(this.y, this.x); }
            static sub(v1, v2) { return new Vector2(v1.x - v2.x, v1.y - v2.y); }
            static fromAngle(angle) { return new Vector2(Math.cos(angle), Math.sin(angle)); }
        }

        // ==================== CHAIN (PHYSICS) ====================
        class Chain {
            constructor(origin, jointCount, linkSize, angleConstraint = Math.PI / 8) {
                this.joints = [origin];
                this.angles = [0];
                this.linkSize = linkSize;
                this.angleConstraint = angleConstraint;
                for (let i = 1; i < jointCount; i++) {
                    this.joints.push(new Vector2(this.joints[i - 1].x, this.joints[i - 1].y + this.linkSize));
                    this.angles.push(0);
                }
            }

            resolve(pos) {
                let targetDir = Vector2.sub(pos, this.joints[0]);
                let targetDistance = targetDir.mag();
                targetDir = targetDir.normalize();

                // SMOOTHER MOVEMENT: Reduced maxMove factor for weightier feel
                const maxMove = this.linkSize * 0.12; 
                if (targetDistance > maxMove) {
                    pos = this.joints[0].add(targetDir.mult(maxMove));
                }

                this.joints[0] = pos;
                this.angles[0] = targetDir.heading();

                for (let i = 1; i < this.joints.length; i++) {
                    const prevJoint = this.joints[i - 1];
                    const curDir = Vector2.sub(prevJoint, this.joints[i]);
                    const curAngle = curDir.heading();
                    
                    // Smooth angle constraint
                    this.angles[i] = constrainAngle(curAngle, this.angles[i - 1], this.angleConstraint);
                    const newDir = Vector2.fromAngle(this.angles[i]).mult(this.linkSize);
                    this.joints[i] = Vector2.sub(prevJoint, newDir);
                }
            }
        }

        // ==================== LILY PADS ====================
        class LilyPad {
            constructor(canvasW, canvasH) {
                this.x = Math.random() * canvasW;
                this.y = Math.random() * canvasH;
                this.size = 20 + Math.random() * 40;
                this.rotation = Math.random() * Math.PI * 2;
                this.color = `hsl(${100 + Math.random() * 40}, 40%, ${30 + Math.random() * 10}%)`;
                this.notchAngle = Math.random() * 0.5 + 0.2;
            }

            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                
                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                ctx.arc(4, 4, this.size, this.notchAngle, Math.PI * 2 - 0.1);
                ctx.lineTo(4, 4);
                ctx.fill();

                // Leaf
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.size, this.notchAngle, Math.PI * 2 - 0.1);
                ctx.lineTo(0, 0);
                ctx.fill();

                // Veins
                ctx.strokeStyle = "rgba(255,255,255,0.1)";
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.restore();
            }
        }

        // ==================== FISH (KOI STYLE) ====================
        class Fish {
            constructor(x, y, size = 1) {
                this.spine = new Chain(new Vector2(x, y), 12, 28 * size, Math.PI / 8);
                this.size = size;
                // Updated width profile for Koi shape (thicker head/body)
                this.bodyWidth = [36, 42, 44, 43, 39, 33, 26, 20, 15, 10].map(w => w * size);
                
                // KOI PALETTES & PATTERNS
                const types = [
                    { name: 'Kohaku', base: '#f4f4f4', spots: '#d83018' },      // White & Red
                    { name: 'Ogon', base: '#ffd700', spots: '#ffa500' },        // Gold
                    { name: 'Showa', base: '#1a1a1a', spots: '#d83018' },       // Black & Red
                    { name: 'Tancho', base: '#f4f4f4', spots: '#d83018' },      // White & Red Spot on head
                    { name: 'Bekko', base: '#f4f4f4', spots: '#111111' }        // White & Black
                ];
                this.type = types[Math.floor(Math.random() * types.length)];
                this.patternSeed = Math.random(); 

                // REDUCED SPEED for wavy relaxation
                this.speed = 0.8 + Math.random() * 0.8; 
                this.roamTarget = new Vector2(x, y);

                // SWAY VARIABLES (Wavy movement)
                this.swayOffset = Math.random() * Math.PI * 2;
                this.swaySpeed = 0.03 + Math.random() * 0.04;
            }

            update() {
                const headPos = this.spine.joints[0];
                const distToTarget = Vector2.sub(this.roamTarget, headPos).mag();
                
                // Update target if reached
                if (distToTarget < 50) this.pickNewRoamTarget();
                
                // 1. Get Base Direction to target
                const directionToTarget = Vector2.sub(this.roamTarget, headPos).normalize();
                
                // 2. Calculate Wavy Sway (Perpendicular Vector)
                // If dir is (x,y), perpendicular is (-y, x)
                this.swayOffset += this.swaySpeed;
                const swayAmount = Math.sin(this.swayOffset) * 0.5; // Amplitude of wave
                const perp = new Vector2(-directionToTarget.y, directionToTarget.x).mult(swayAmount);
                
                // 3. Combine vectors (Forward + Sway)
                const finalDir = directionToTarget.add(perp).normalize();

                // 4. Move
                const move = finalDir.mult(this.speed);
                this.spine.resolve(headPos.add(move));
            }
            
            pickNewRoamTarget() {
                const pad = 100;
                const x = Math.random() * (canvas.width - 2 * pad) + pad;
                const y = Math.random() * (canvas.height - 2 * pad) + pad;
                this.roamTarget = new Vector2(x, y);
            }

            // Draw the fish twice: once for shadow, once for body
            display(ctx) {
                // 1. SHADOW (Offset and semi-transparent)
                ctx.save();
                ctx.translate(15, 15); // Shadow offset
                ctx.fillStyle = "rgba(0, 0, 0, 0.25)";
                this.drawBodyShape(ctx); 
                ctx.fill();
                ctx.restore();

                // 2. ACTUAL FISH
                ctx.save();
                
                // Clip the body shape so patterns stay inside
                this.drawBodyShape(ctx);
                ctx.clip();

                // Fill Base Color
                ctx.fillStyle = this.type.base;
                ctx.fill();

                // Fill Patterns
                if (this.type.name === 'Tancho') {
                    // Specific pattern: Red circle on head
                    const head = this.spine.joints[0];
                    ctx.fillStyle = this.type.spots;
                    ctx.beginPath();
                    ctx.arc(head.x, head.y, 12 * this.size, 0, Math.PI*2);
                    ctx.fill();
                } else {
                    // Random blotches for others
                    ctx.fillStyle = this.type.spots;
                    const j = this.spine.joints;
                    for (let k = 1; k < 10; k+=2) {
                        if (Math.sin(k * this.patternSeed * 10) > -0.2) {
                            ctx.beginPath();
                            ctx.arc(j[k].x, j[k].y, this.bodyWidth[k] * 0.8, 0, Math.PI*2);
                            ctx.fill();
                        }
                    }
                }
                
                // Subtle 3D shading gradient on top
                const head = this.spine.joints[0];
                const grad = ctx.createRadialGradient(head.x, head.y, 10, head.x, head.y, 200 * this.size);
                grad.addColorStop(0, "rgba(255,255,255,0.15)");
                grad.addColorStop(1, "rgba(0,0,0,0.1)");
                ctx.fillStyle = grad;
                ctx.fill();

                ctx.restore(); // End clipping

                // 3. FINS (Drawn on top for transparency effect)
                this.drawFins(ctx);
                
                // 4. EYES
                this.drawEyes(ctx);
            }

            drawBodyShape(ctx) {
                const j = this.spine.joints;
                const a = this.spine.angles;
                const getSide = (i, ang) => {
                    return new Vector2(
                        j[i].x + Math.cos(a[i] + ang) * (this.bodyWidth[i] / 2),
                        j[i].y + Math.sin(a[i] + ang) * (this.bodyWidth[i] / 2)
                    );
                };

                ctx.beginPath();
                // Right side
                ctx.moveTo(getSide(0, Math.PI/2).x, getSide(0, Math.PI/2).y);
                for(let i=0; i<10; i++) {
                    const p = getSide(i, Math.PI/2);
                    if (i<9) {
                        const nextP = getSide(i+1, Math.PI/2);
                        const cp = new Vector2((p.x + nextP.x)/2, (p.y + nextP.y)/2);
                        ctx.quadraticCurveTo(p.x, p.y, cp.x, cp.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                // Tail end
                ctx.lineTo(getSide(9, -Math.PI/2).x, getSide(9, -Math.PI/2).y);
                // Left side
                for(let i=9; i>=0; i--) {
                    const p = getSide(i, -Math.PI/2);
                    if (i>0) {
                        const nextP = getSide(i-1, -Math.PI/2);
                        const cp = new Vector2((p.x + nextP.x)/2, (p.y + nextP.y)/2);
                        ctx.quadraticCurveTo(p.x, p.y, cp.x, cp.y);
                    } else {
                        ctx.lineTo(p.x, p.y);
                    }
                }
                // Round Head
                const nose = new Vector2(j[0].x + Math.cos(a[0])*this.bodyWidth[0]*0.5, j[0].y + Math.sin(a[0])*this.bodyWidth[0]*0.5);
                ctx.quadraticCurveTo(getSide(0, -Math.PI/2).x, getSide(0, -Math.PI/2).y, nose.x, nose.y);
                ctx.closePath();
            }

            drawFins(ctx) {
                const j = this.spine.joints;
                const a = this.spine.angles;
                
                ctx.save();
                ctx.fillStyle = "rgba(255, 255, 255, 0.4)";
                
                // Pectoral Fins
                const drawPec = (side) => {
                    const pos = j[3];
                    const angle = a[2] + (side * Math.PI/2.5);
                    ctx.save();
                    ctx.translate(pos.x, pos.y);
                    ctx.rotate(angle);
                    ctx.beginPath();
                    ctx.ellipse(0, 0, 35*this.size, 15*this.size, 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.restore();
                }
                drawPec(1);
                drawPec(-1);

                // Tail
                const tailBase = j[9];
                const tailAngle = a[9];
                ctx.save();
                ctx.translate(tailBase.x, tailBase.y);
                ctx.rotate(tailAngle);
                ctx.beginPath();
                ctx.moveTo(0,0);
                ctx.quadraticCurveTo(-30*this.size, 20*this.size, -40*this.size, 30*this.size);
                ctx.quadraticCurveTo(-20*this.size, 0, -40*this.size, -30*this.size);
                ctx.quadraticCurveTo(-30*this.size, -20*this.size, 0, 0);
                ctx.fill();
                ctx.restore();

                ctx.restore();
            }

            drawEyes(ctx) {
                const head = this.spine.joints[0];
                const ang = this.spine.angles[0];
                const offset = this.bodyWidth[0]/2 - 2;
                
                const drawEye = (side) => {
                    const ex = head.x + Math.cos(ang + side * Math.PI/2.5) * offset;
                    const ey = head.y + Math.sin(ang + side * Math.PI/2.5) * offset;
                    
                    ctx.beginPath();
                    ctx.arc(ex, ey, 4*this.size, 0, Math.PI*2);
                    ctx.fillStyle = "black";
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(ex + 1, ey - 1, 1.5*this.size, 0, Math.PI*2);
                    ctx.fillStyle = "white";
                    ctx.fill();
                }
                drawEye(1);
                drawEye(-1);
            }
        }

        // ==================== UTILITY ====================
        function constrainAngle(angle, anchor, constraint) {
            const diff = ((((angle - anchor + Math.PI) % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2)) - Math.PI;
            return anchor + Math.max(-constraint, Math.min(constraint, diff));
        }

        // ==================== BACKGROUND & RIPPLES ====================
        let lilies = [];
        let ripples = [];

        function initEnvironment() {
            lilies = [];
            // Create a few lily pads
            for(let i=0; i<6; i++) {
                lilies.push(new LilyPad(canvas.width, canvas.height));
            }
        }

        function createRipple(x, y) {
            ripples.push({x, y, r: 0, alpha: 1, lw: 3});
        }

        function drawBackground(ctx) {
            const w = ctx.canvas.width;
            const h = ctx.canvas.height;

            // 1. Water Base (Deep Pond Gradient)
            const grad = ctx.createLinearGradient(0, 0, 0, h);
            grad.addColorStop(0, '#102e33'); 
            grad.addColorStop(1, '#050f10'); 
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,w,h);

            // 3. Lily Pads
            lilies.forEach(pad => pad.draw(ctx));

            // 4. Water Ripples (Animated)
            ctx.strokeStyle = "rgba(180, 220, 255, 0.4)";
            for(let i=ripples.length-1; i>=0; i--) {
                const r = ripples[i];
                r.r += 2;      // Expand
                r.alpha -= 0.02; // Fade
                r.lw *= 0.98;  // Thin out
                
                if(r.alpha <= 0) {
                    ripples.splice(i, 1);
                } else {
                    ctx.lineWidth = r.lw;
                    ctx.globalAlpha = r.alpha;
                    ctx.beginPath();
                    ctx.ellipse(r.x, r.y, r.r, r.r * 0.6, 0, 0, Math.PI*2); // Ellipse for perspective
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
            }
        }

        // ==================== GAME LOGIC ====================
        let score = 0;
        let gameRunning = false;
        let fishes = [];
        let highScore = localStorage.getItem('fishHighScore') || 0;
        let spawnInterval = null;
        let canvas, ctx;

        // DOM
        const startScreen = document.getElementById('startScreen');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const gameOverScreen = document.getElementById('gameOver');
        const finalScoreEl = document.getElementById('finalScore');
        const highScoreEl = document.getElementById('highScore');

        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('playAgainBtn').addEventListener('click', startGame);
        document.getElementById('menuBtn').addEventListener('click', toMenu);
        
        // Back Button Logic
        const globalBack = document.getElementById('global-back');
        if (globalBack) {
            globalBack.addEventListener('click', function() {
                location.href = '../index.html';
            });
        }

        function initCanvas() {
            canvas = document.getElementById('fishCanvas');
            ctx = canvas.getContext('2d');
            resize();
            window.addEventListener('resize', resize);
            
            // Mouse/Touch Interaction
            canvas.addEventListener('mousedown', handleInput);
            canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleInput(e.touches[0]); }, {passive: false});
        }

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            initEnvironment(); // Re-scatter lilies on resize
        }

        function spawnFish() {
            if(!gameRunning) return;
            const size = 0.5 + Math.random() * 0.7; // Varied sizes
            
            // Spawn outside screen
            let x, y;
            if (Math.random() < 0.5) {
                x = Math.random() * canvas.width;
                y = Math.random() < 0.5 ? -100 : canvas.height + 100;
            } else {
                x = Math.random() < 0.5 ? -100 : canvas.width + 100;
                y = Math.random() * canvas.height;
            }
            
            fishes.push(new Fish(x, y, size));
        }

        function handleInput(e) {
            if(!gameRunning) return;
            
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            createRipple(clickX, clickY);

            // Check Collision
            // Reverse loop to catch top fish first
            for (let i = fishes.length - 1; i >= 0; i--) {
                const fish = fishes[i];
                const head = fish.spine.joints[0];
                const dx = clickX - head.x;
                const dy = clickY - head.y;
                
                // Hitbox logic
                if (Math.sqrt(dx*dx + dy*dy) < 50 * fish.size) {
                    catchFish(i, head.x, head.y);
                    break;
                }
            }
        }

        function catchFish(index, x, y) {
            fishes.splice(index, 1);
            score += 10;
            scoreDisplay.textContent = score;
            
            // Floating Text
            const el = document.createElement('div');
            el.className = 'points-display';
            el.textContent = '+10';
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.body.appendChild(el);
            setTimeout(() => el.remove(), 800);

            // Immediate spawn replacement
            setTimeout(spawnFish, 500);
        }

        function startGame() {
            gameRunning = true;
            score = 0;
            scoreDisplay.textContent = "0";
            fishes = [];
            startScreen.style.display = 'none';
            gameOverScreen.classList.remove('show');
            
            initCanvas();
            initEnvironment();
            
            // Initial batch
            for(let i=0; i<8; i++) {
                // Spawn inside randomly for start
                const f = new Fish(Math.random()*canvas.width, Math.random()*canvas.height, 0.6 + Math.random()*0.4);
                fishes.push(f);
            }

            animate();
            if(spawnInterval) clearInterval(spawnInterval);
            spawnInterval = setInterval(spawnFish, 1500);
        }

        function toMenu() {
            gameRunning = false;
            startScreen.style.display = 'flex';
            gameOverScreen.classList.remove('show');
        }

        function animate() {
            if(!gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Background (Pond + Lilies + Ripples)
            drawBackground(ctx);

            // 2. Draw Fishes
            fishes.forEach(f => {
                f.update();
                f.display(ctx);
            });

            requestAnimationFrame(animate);
        }

        // Init High Score
        highScoreEl.textContent = `Best: ${highScore}`;
        
        // Show initial background on load
        initCanvas();
        initEnvironment();
        drawBackground(ctx);

    </script>
</body>
</html>
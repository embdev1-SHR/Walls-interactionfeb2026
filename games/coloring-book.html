<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Jungle Wall ¬∑ Separate Layers</title>
<style>
  /* ----- RESET & GLOBAL ----- */
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    -webkit-user-select: none;
    user-select: none;
  }
  html, body {
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: #1e3a1e; /* boundary color */
  }
  body {
    font-family: 'Comic Sans MS', 'Chalkboard SE', cursive;
    touch-action: none;
  }

  /* ----- DECORATIVE JUNGLE BG (purely cosmetic) ----- */
  .jungle-bg {
    position: fixed;
    inset: 0;
    pointer-events: none;
    z-index: 0;
    opacity: 0.15;
    background: repeating-linear-gradient(45deg, 
      #2a5a2a 0px, #2a5a2a 40px,
      #3a6e3a 40px, #3a6e3a 80px);
    background-size: 80px 80px;
  }
  .floating-leaf {
    position: absolute;
    font-size: 90px;
    opacity: 0.2;
    animation: floatLeaf 20s infinite linear;
    pointer-events: none;
  }
  @keyframes floatLeaf {
    0% { transform: translate(0, 0) rotate(0deg); }
    100% { transform: translate(120px, -120px) rotate(180deg); }
  }

  /* ----- MODAL POPUP ‚Äì CHOOSE PLAYERS (completely separate) ----- */
  #playerModal {
    position: fixed;
    inset: 0;
    background: rgba(10, 20, 5, 0.85);
    backdrop-filter: blur(12px);
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10000;
  }
  .modal-card {
    background: #2d6a2d;
    padding: 40px 30px;
    border-radius: 80px;
    box-shadow: 0 20px 40px rgba(0,0,0,0.6);
    display: flex;
    gap: 50px;
    flex-wrap: wrap;
    justify-content: center;
  }
  .player-choice {
    background: #fff0a0;
    width: 220px;
    height: 220px;
    border-radius: 60px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    gap: 10px;
    box-shadow: 0 12px 0 #5a3e1e;
    cursor: pointer;
  }
  .player-choice:active {
    transform: scale(0.9);
    box-shadow: 0 6px 0 #5a3e1e;
  }
  .player-choice span { font-size: 70px; }
  .player-choice p {
    font-size: 32px;
    font-weight: 800;
    color: #1e3a1e;
    text-shadow: 2px 2px 0 #ffd966;
  }
  .hidden-modal { display: none !important; }

  /* ----- CANVAS GRID ‚Äì 3 EQUAL COLUMNS, SIMPLE 2px BOUNDARY ----- */
  #canvas-grid {
    position: fixed;
    inset: 0;
    display: none;  /* shown after modal */
    grid-template-columns: 1fr 1fr 1fr;
    background: #1e3a1e;  /* solid dark green ‚Äì visible as boundary */
    gap: 2px;            /* simple line ‚Äì no shadow, no 3d */
    padding: 0;
    z-index: 10;
  }
  .grid-1 {
    grid-template-columns: 1fr !important;
    gap: 0 !important;
  }
  .grid-1 .canvas-panel:first-child {
    grid-column: 1 / -1;
  }

  /* ----- EACH PANEL = ITS OWN LAYER, COMPLETELY ISOLATED ----- */
  .canvas-panel {
    position: relative;
    background: #f5ffe0;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    border: none;
    outline: none;
    box-shadow: none;
    /* Each panel is an independent stacking context */
    isolation: isolate;
  }

  .canvas-holder {
    flex: 1;
    position: relative;
    background: transparent;
    min-height: 0;
    width: 100%;
    height: 100%;
  }

  /* canvas elements ‚Äì each layer owns its drawing */
  .draw-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: block;
    cursor: crosshair;
    /* each canvas is its own layer */
    isolation: isolate;
  }
  .line-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    isolation: isolate;
  }

  /* ----- TOOLBAR ‚Äì INSIDE EACH LAYER, TOTALLY INDEPENDENT ----- */
  .inside-toolbar {
    background: #3a6e3a;
    padding: 8px 12px;
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    gap: 8px;
    border: none;
    border-top: 2px solid #2b4a2b;
    box-shadow: none;
    min-height: 64px;
    /* toolbar belongs to its layer */
    isolation: isolate;
  }

  /* TOOL STYLES ‚Äì flat, no shared state */
  .inside-toolbar .color-swatch {
    width: 34px;
    height: 34px;
    border-radius: 50%;
    border: 2px solid #ffffffcc;
    box-shadow: none;
    flex-shrink: 0;
  }
  .inside-toolbar .tpl-btn {
    width: 44px;
    height: 44px;
    font-size: 26px;
    background: #fffae6;
    border: 2px solid white;
    border-radius: 12px;
    box-shadow: none;
  }
  .inside-toolbar .tool-btn {
    width: 38px;
    height: 38px;
    background: white;
    border: 2px solid white;
    border-radius: 30%;
    font-size: 20px;
    box-shadow: none;
  }
  .inside-toolbar .size-slider {
    width: 70px;
    height: 6px;
    background: #ffb347;
    border-radius: 6px;
    border: 1px solid white;
  }
  .inside-toolbar .ctrl-btn {
    padding: 6px 10px;
    background: #3d2e1a;
    border: 2px solid #ffc085;
    border-radius: 30px;
    color: white;
    font-size: 13px;
    font-weight: bold;
    box-shadow: none;
  }
  .inside-toolbar .bar-divider {
    width: 2px;
    height: 26px;
    background: rgba(255,255,200,0.4);
    margin: 0 2px;
  }

  /* no headers ‚Äì clean layers */
  .panel-header { display: none; }

  /* pointer dot ‚Äì belongs to global UI, not canvas layers */
  .pointer-dot {
    position: fixed;
    border-radius: 50%;
    pointer-events: none;
    z-index: 9999;
    transform: translate(-50%,-50%);
    border: 2px solid white;
    filter: drop-shadow(0 0 2px black);
  }
  .animal-label {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 90px;
    color: #FFD700;
    text-shadow: 4px 4px 0 #2a4a1a;
    pointer-events: none;
    z-index: 10001;
    animation: popFade 1.6s ease-out forwards;
  }
  @keyframes popFade {
    0% { opacity:0; transform:translate(-50%,-50%) scale(0.2); }
    30% { opacity:1; transform:translate(-50%,-50%) scale(1.2); }
    100% { opacity:0; transform:translate(-50%,-60%) scale(0.8); }
  }
</style>
</head>
<body>
  <div class="jungle-bg" id="jungleBg"></div>

  <!-- PLAYER POPUP ‚Äì SEPARATE LAYER CHOICE -->
  <div id="playerModal">
    <div class="modal-card">
      <div id="choose1" class="player-choice">
        <span>üë§</span>
        <p>1 Player</p>
      </div>
      <div id="choose3" class="player-choice">
        <span>üë•</span>
        <p>3 Players</p>
      </div>
    </div>
  </div>

  <!-- CANVAS GRID ‚Äì EACH PANEL = INDEPENDENT LAYER -->
  <div id="canvas-grid" class="grid-3">
    <!-- LAYER 1 ‚Äì Player 1 ‚Äì completely separate state -->
    <div id="panel1" class="canvas-panel">
      <div class="canvas-holder" id="holder1">
        <canvas id="paintCanvas1" class="draw-canvas"></canvas>
        <canvas id="lineCanvas1" class="line-canvas"></canvas>
      </div>
      <div id="toolbar1" class="inside-toolbar"></div>
    </div>
    <!-- LAYER 2 ‚Äì Player 2 ‚Äì independent memory, tools, canvas -->
    <div id="panel2" class="canvas-panel">
      <div class="canvas-holder" id="holder2">
        <canvas id="paintCanvas2" class="draw-canvas"></canvas>
        <canvas id="lineCanvas2" class="line-canvas"></canvas>
      </div>
      <div id="toolbar2" class="inside-toolbar"></div>
    </div>
    <!-- LAYER 3 ‚Äì Player 3 ‚Äì no cross-layer contamination -->
    <div id="panel3" class="canvas-panel">
      <div class="canvas-holder" id="holder3">
        <canvas id="paintCanvas3" class="draw-canvas"></canvas>
        <canvas id="lineCanvas3" class="line-canvas"></canvas>
      </div>
      <div id="toolbar3" class="inside-toolbar"></div>
    </div>
  </div>

<script>
  (function() {
    // ----------------------------------------------------------------
    //   üé® COMPLETELY SEPARATE LAYERS ‚Äì EACH PLAYER OWNS ITS OWN:
    //   - currentColor, brushSize, activeTool, currentTemplate
    //   - masks, canvas state, undo history (via buildMasks)
    //   - tool UI is per panel, events update only that layer's state
    // ----------------------------------------------------------------
    
    // ------ MASTER COLOR PALETTE (only used to populate swatches) -----
    const MASTER_COLORS = [
      '#FF6B6B','#FF1493','#FF6347','#FFA07A','#FFD700','#F7DC6F',
      '#4ECDC4','#45B7D1','#20B2AA','#98D8C8','#52B788','#BB8FCE',
      '#fff','#888','#333'
    ];

    // ------ TEMPLATE LIBRARY (shared, but drawing is per layer) -----
    const TEMPLATES = {
      elephant: {emoji:'üêò', draw: drawElephant},
      lion:     {emoji:'ü¶Å', draw: drawLion},
      monkey:   {emoji:'üêµ', draw: drawMonkey},
      parrot:   {emoji:'ü¶ú', draw: drawParrot},
      snake:    {emoji:'üêç', draw: drawSnake},
      tiger:    {emoji:'üêØ', draw: drawTiger},
      giraffe:  {emoji:'ü¶í', draw: drawGiraffe},
      frog:     {emoji:'üê∏', draw: drawFrog}
    };

    // ------ PER‚ÄëLAYER STATE ‚Äì EACH PANEL GETS ITS OWN COPY -----
    // This is the key to "each layer acts like separate layer"
    const panelState = {};

    // Panel IDs
    const PANEL_IDS = ['panel1', 'panel2', 'panel3'];
    const PAINT_IDS = ['paintCanvas1', 'paintCanvas2', 'paintCanvas3'];
    const LINE_IDS = ['lineCanvas1', 'lineCanvas2', 'lineCanvas3'];
    const TOOLBAR_IDS = ['toolbar1', 'toolbar2', 'toolbar3'];
    const HOLDER_IDS = ['holder1', 'holder2', 'holder3'];

    // ----- INDEPENDENT STATE INITIALIZER -----
    function createInitialLayerState() {
      return {
        currentColor: MASTER_COLORS[0],
        brushSize: 26,
        activeTool: 'brush',
        currentTemplate: 'elephant',
        // Each layer has its own masks, contexts, etc. ‚Äì stored in panels object
      };
    }

    // ----- PANELS OBJECT (holds canvas contexts and masks per layer) -----
    let panels = {};

    // ----- HELPER: hexToRgb (pure) -----
    function hexToRgb(hex) {
      let c = document.createElement('canvas').getContext('2d');
      c.fillStyle = hex;
      c.fillRect(0,0,1,1);
      return c.getImageData(0,0,1,1).data;
    }

    // ----- DILATE (mask operation, per layer) -----
    function dilateMask(mask, w, h, iter) {
      let cur = new Uint8Array(mask);
      for (let it=0; it<iter; it++) {
        let nxt = new Uint8Array(w*h);
        for (let y=0; y<h; y++) for (let x=0; x<w; x++) {
          let i = y*w + x;
          if (cur[i]) { nxt[i]=1; continue; }
          if (x>0 && cur[i-1]) nxt[i]=1;
          else if (x<w-1 && cur[i+1]) nxt[i]=1;
          else if (y>0 && cur[i-w]) nxt[i]=1;
          else if (y<h-1 && cur[i+w]) nxt[i]=1;
        }
        cur = nxt;
      }
      return cur;
    }

    // ----- BUILD MASKS ‚Äì PER LAYER, using that layer's template -----
    function buildMasksForPanel(panelId, templateKey) {
      let p = panels[panelId];
      if (!p) return;
      let { paintCtx, lineCtx, width, height } = p;

      paintCtx.fillStyle = '#fff';
      paintCtx.fillRect(0, 0, width, height);

      let off = document.createElement('canvas');
      off.width = width; off.height = height;
      let offCtx = off.getContext('2d');
      offCtx.fillStyle = '#fff';
      offCtx.fillRect(0,0,width,height);
      TEMPLATES[templateKey].draw(offCtx, width, height);

      let img = offCtx.getImageData(0,0,width,height);
      let d = img.data;
      let outlineMask = new Uint8Array(width*height);
      for (let i=0; i<width*height; i++) {
        let lum = d[i*4]*0.299 + d[i*4+1]*0.587 + d[i*4+2]*0.114;
        if (lum < 180) outlineMask[i] = 1;
      }

      let dilated = dilateMask(outlineMask, width, height, 3);
      let exterior = new Uint8Array(width*height);
      let stack = [];
      for (let x=0; x<width; x++) {
        if (!dilated[x]) { exterior[x]=1; stack.push(x,0); }
        let bi = (height-1)*width + x;
        if (!dilated[bi]) { exterior[bi]=1; stack.push(x,height-1); }
      }
      for (let y=1; y<height-1; y++) {
        let li = y*width;
        if (!dilated[li]) { exterior[li]=1; stack.push(0,y); }
        let ri = y*width + width-1;
        if (!dilated[ri]) { exterior[ri]=1; stack.push(width-1,y); }
      }
      while (stack.length) {
        let sy = stack.pop(), sx = stack.pop();
        let idx = sy*width + sx;
        if (sx+1<width && !exterior[idx+1] && !dilated[idx+1]) { exterior[idx+1]=1; stack.push(sx+1,sy); }
        if (sx-1>=0 && !exterior[idx-1] && !dilated[idx-1]) { exterior[idx-1]=1; stack.push(sx-1,sy); }
        if (sy+1<height && !exterior[idx+width] && !dilated[idx+width]) { exterior[idx+width]=1; stack.push(sx,sy+1); }
        if (sy-1>=0 && !exterior[idx-width] && !dilated[idx-width]) { exterior[idx-width]=1; stack.push(sx,sy-1); }
      }

      let paintableMask = new Uint8Array(width*height);
      for (let i=0; i<width*height; i++) {
        if (!outlineMask[i] && !exterior[i]) paintableMask[i] = 1;
      }

      // line canvas
      let lineData = new Uint8ClampedArray(width*height*4);
      for (let i=0; i<width*height; i++) {
        if (outlineMask[i]) {
          lineData[i*4] = d[i*4];
          lineData[i*4+1] = d[i*4+1];
          lineData[i*4+2] = d[i*4+2];
          lineData[i*4+3] = 255;
        }
      }
      lineCtx.clearRect(0,0,width,height);
      lineCtx.putImageData(new ImageData(lineData, width, height), 0,0);

      // paint background
      let pImg = paintCtx.getImageData(0,0,width,height);
      let pd = pImg.data;
      for (let i=0; i<width*height; i++) {
        if (exterior[i] || outlineMask[i]) {
          pd[i*4] = 210; pd[i*4+1]=220; pd[i*4+2]=200; pd[i*4+3]=255;
        } else {
          pd[i*4]=255; pd[i*4+1]=255; pd[i*4+2]=255; pd[i*4+3]=255;
        }
      }
      paintCtx.putImageData(pImg, 0,0);
      p.outlineMask = outlineMask;
      p.paintableMask = paintableMask;
    }

    // ----- CONSTRAIN PAINT (per layer) -----
    function constrainPaint(pid, x0, y0, x1, y1) {
      let p = panels[pid];
      if (!p) return;
      let { paintCtx, paintableMask, width, height } = p;
      let ix0 = Math.max(0, Math.floor(x0)), iy0 = Math.max(0, Math.floor(y0));
      let ix1 = Math.min(width, Math.ceil(x1)), iy1 = Math.min(height, Math.ceil(y1));
      if (ix1<=ix0 || iy1<=iy0) return;
      let reg = paintCtx.getImageData(ix0, iy0, ix1-ix0, iy1-iy0);
      let d = reg.data, changed = false;
      for (let row=0; row<iy1-iy0; row++) {
        for (let col=0; col<ix1-ix0; col++) {
          let gx = ix0+col, gy = iy0+row;
          let mi = gy * width + gx;
          if (!paintableMask[mi]) {
            let pi = (row*(ix1-ix0) + col)*4;
            d[pi] = 210; d[pi+1]=220; d[pi+2]=200; d[pi+3]=255;
            changed = true;
          }
        }
      }
      if (changed) paintCtx.putImageData(reg, ix0, iy0);
    }

    // ----- BRUSH STROKE (per layer, uses layer's own state) -----
    function brushStroke(pid, x1,y1,x2,y2,color,size) {
      let p = panels[pid];
      if (!p) return;
      let ctx = p.paintCtx;
      ctx.save();
      ctx.lineWidth = size;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      ctx.restore();
      let pad = Math.ceil(size/2)+2;
      constrainPaint(pid, Math.min(x1,x2)-pad, Math.min(y1,y2)-pad, Math.max(x1,x2)+pad, Math.max(y1,y2)+pad);
    }

    function brushDot(pid, cx,cy,color,size) {
      let p = panels[pid];
      if (!p) return;
      let ctx = p.paintCtx;
      ctx.save();
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(cx,cy,size/2,0,2*Math.PI);
      ctx.fill();
      ctx.restore();
      let pad = Math.ceil(size/2)+2;
      constrainPaint(pid, cx-pad, cy-pad, cx+pad, cy+pad);
    }

    function floodFill(pid, sx,sy,color) {
      let p = panels[pid];
      if (!p) return;
      let { paintCtx, paintableMask, width, height } = p;
      sx = Math.round(sx); sy = Math.round(sy);
      if (sx<0||sx>=width||sy<0||sy>=height) return;
      if (!paintableMask[sy*width+sx]) return;
      let img = paintCtx.getImageData(0,0,width,height);
      let data = img.data;
      let si = (sy*width+sx)*4;
      let sr=data[si], sg=data[si+1], sb=data[si+2];
      let fc = hexToRgb(color);
      let fr=fc[0], fg=fc[1], fb=fc[2];
      if (Math.abs(sr-fr)<3 && Math.abs(sg-fg)<3 && Math.abs(sb-fb)<3) return;
      let visited = new Uint8Array(width*height);
      let stack = [sx,sy];
      while(stack.length) {
        let y = stack.pop(), x = stack.pop();
        if (x<0||x>=width||y<0||y>=height) continue;
        let vi = y*width + x;
        if (visited[vi] || !paintableMask[vi]) continue;
        let pi = vi*4;
        if (Math.abs(data[pi]-sr)>32||Math.abs(data[pi+1]-sg)>32||Math.abs(data[pi+2]-sb)>32) continue;
        visited[vi]=1;
        data[pi]=fr; data[pi+1]=fg; data[pi+2]=fb; data[pi+3]=255;
        stack.push(x+1,y, x-1,y, x,y+1, x,y-1);
      }
      paintCtx.putImageData(img,0,0);
    }

    // ----- INIT EACH PANEL ‚Äì creates independent layer with its own state -----
    function initPanels() {
      PANEL_IDS.forEach((pid, idx) => {
        // Skip if already initialized? We'll rebuild fresh.
        let canvas = document.getElementById(PAINT_IDS[idx]);
        let lineCanvas = document.getElementById(LINE_IDS[idx]);
        let holder = document.getElementById(HOLDER_IDS[idx]);
        if (!canvas || !holder) return;

        let w = holder.clientWidth || 600;
        let h = holder.clientHeight || 500;
        canvas.width = w; canvas.height = h;
        lineCanvas.width = w; lineCanvas.height = h;

        let paintCtx = canvas.getContext('2d', {willReadFrequently: true});
        let lineCtx = lineCanvas.getContext('2d');

        // Each panel gets its own state object (stored in panelState)
        if (!panelState[pid]) {
          panelState[pid] = createInitialLayerState();
        }

        panels[pid] = {
          canvas, paintCtx, lineCanvas, lineCtx,
          width: w, height: h,
          activePointers: {}
        };

        // Build masks using this layer's current template
        buildMasksForPanel(pid, panelState[pid].currentTemplate);

        // ----- EVENT LISTENERS ‚Äì use layer's own state -----
        function getCoords(e) {
          let rect = canvas.getBoundingClientRect();
          let scaleX = canvas.width / rect.width;
          let scaleY = canvas.height / rect.height;
          return {
            x: (e.clientX - rect.left) * scaleX,
            y: (e.clientY - rect.top) * scaleY
          };
        }

        function handleDown(e) {
          e.preventDefault();
          let state = panelState[pid];
          let c = getCoords(e);
          
          if (state.activeTool === 'fill') {
            floodFill(pid, c.x, c.y, state.currentColor);
            return;
          }
          let color = (state.activeTool === 'eraser') ? '#FFFFFF' : state.currentColor;
          panels[pid].activePointers[e.pointerId] = {x: c.x, y: c.y, color: color};
          brushDot(pid, c.x, c.y, color, state.brushSize);

          let dot = document.createElement('div');
          dot.className = 'pointer-dot';
          dot.id = `dot-${pid}-${e.pointerId}`;
          dot.style.left = e.clientX+'px';
          dot.style.top = e.clientY+'px';
          dot.style.background = color;
          dot.style.width = dot.style.height = Math.min(state.brushSize, 36)+'px';
          document.body.appendChild(dot);
        }

        function handleMove(e) {
          e.preventDefault();
          let ptr = panels[pid].activePointers[e.pointerId];
          if (!ptr) return;
          let c = getCoords(e);
          let state = panelState[pid];
          brushStroke(pid, ptr.x, ptr.y, c.x, c.y, ptr.color, state.brushSize);
          ptr.x = c.x; ptr.y = c.y;
          let dot = document.getElementById(`dot-${pid}-${e.pointerId}`);
          if (dot) { dot.style.left = e.clientX+'px'; dot.style.top = e.clientY+'px'; }
        }

        function handleUp(e) {
          delete panels[pid].activePointers[e.pointerId];
          let dot = document.getElementById(`dot-${pid}-${e.pointerId}`);
          if (dot) dot.remove();
        }

        // Remove old listeners to avoid duplication
        canvas.removeEventListener('pointerdown', handleDown);
        canvas.removeEventListener('pointermove', handleMove);
        canvas.removeEventListener('pointerup', handleUp);
        canvas.removeEventListener('pointercancel', handleUp);
        
        canvas.addEventListener('pointerdown', handleDown);
        canvas.addEventListener('pointermove', handleMove);
        canvas.addEventListener('pointerup', handleUp);
        canvas.addEventListener('pointercancel', handleUp);
      });
    }

    // ----- BUILD TOOLBAR ‚Äì EACH LAYER GETS ITS OWN UI, BOUND TO ITS OWN STATE -----
    function buildPanelToolbars() {
      PANEL_IDS.forEach((pid, idx) => {
        let toolbar = document.getElementById(TOOLBAR_IDS[idx]);
        if (!toolbar) return;
        toolbar.innerHTML = '';

        // Each toolbar uses the layer's state, not global variables
        let state = panelState[pid];
        if (!state) {
          panelState[pid] = createInitialLayerState();
          state = panelState[pid];
        }

        // ---- Color swatches (each swatch updates ONLY this layer's currentColor) ----
        MASTER_COLORS.forEach(c => {
          let sw = document.createElement('div');
          sw.className = 'color-swatch';
          sw.style.background = c;
          if (c === '#fff') sw.style.border = '2px solid #ccc';
          sw.dataset.color = c;
          sw.addEventListener('click', () => { 
            state.currentColor = c; 
            refreshLayerUI(pid); 
          });
          toolbar.appendChild(sw);
        });

        let div1 = document.createElement('div'); div1.className = 'bar-divider'; toolbar.appendChild(div1);

        // ---- Animal templates (updates ONLY this layer's template) ----
        let tmplKeys = Object.keys(TEMPLATES).slice(0,6);
        tmplKeys.forEach(key => {
          let btn = document.createElement('button');
          btn.className = 'tpl-btn';
          btn.textContent = TEMPLATES[key].emoji;
          btn.dataset.template = key;
          btn.addEventListener('click', () => {
            state.currentTemplate = key;
            buildMasksForPanel(pid, state.currentTemplate);
            refreshLayerUI(pid);
            let lbl = document.createElement('div');
            lbl.className = 'animal-label';
            lbl.textContent = TEMPLATES[key].emoji;
            document.body.appendChild(lbl);
            setTimeout(()=>lbl.remove(), 1600);
          });
          toolbar.appendChild(btn);
        });

        let div2 = document.createElement('div'); div2.className = 'bar-divider'; toolbar.appendChild(div2);

        // ---- Brush size slider (affects only this layer) ----
        let slider = document.createElement('input');
        slider.type = 'range'; slider.className = 'size-slider';
        slider.min = 5; slider.max = 60; slider.value = state.brushSize;
        slider.addEventListener('input', (e) => { state.brushSize = parseInt(e.target.value); });
        toolbar.appendChild(slider);

        let div3 = document.createElement('div'); div3.className = 'bar-divider'; toolbar.appendChild(div3);

        // ---- Tools: brush, fill, eraser (each toggles this layer's activeTool) ----
        let brushBtn = document.createElement('button');
        brushBtn.className = 'tool-btn'; brushBtn.dataset.tool = 'brush'; brushBtn.textContent = '‚úèÔ∏è';
        brushBtn.addEventListener('click', () => { state.activeTool = 'brush'; refreshLayerUI(pid); });
        toolbar.appendChild(brushBtn);

        let fillBtn = document.createElement('button');
        fillBtn.className = 'tool-btn'; fillBtn.dataset.tool = 'fill'; fillBtn.textContent = 'üíß';
        fillBtn.addEventListener('click', () => { state.activeTool = 'fill'; refreshLayerUI(pid); });
        toolbar.appendChild(fillBtn);

        let eraserBtn = document.createElement('button');
        eraserBtn.className = 'tool-btn'; eraserBtn.dataset.tool = 'eraser'; eraserBtn.textContent = 'üßΩ';
        eraserBtn.addEventListener('click', () => { state.activeTool = 'eraser'; refreshLayerUI(pid); });
        toolbar.appendChild(eraserBtn);

        let div4 = document.createElement('div'); div4.className = 'bar-divider'; toolbar.appendChild(div4);

        // ---- Clear (resets only this layer) ----
        let clearBtn = document.createElement('button');
        clearBtn.className = 'ctrl-btn'; clearBtn.textContent = 'üßπClear';
        clearBtn.addEventListener('click', () => { 
          buildMasksForPanel(pid, state.currentTemplate); 
        });
        toolbar.appendChild(clearBtn);

        // ---- Back (global, but kept per toolbar) ----
        let backBtn = document.createElement('button');
        backBtn.className = 'ctrl-btn'; backBtn.textContent = 'üîôMenu';
        backBtn.addEventListener('click', () => { location.href = '../index.html'; });
        toolbar.appendChild(backBtn);

        // Initial active highlight
        refreshLayerUI(pid);
      });
    }

    // ----- Refresh UI for a specific layer (only that panel's toolbar) -----
    function refreshLayerUI(pid) {
      let state = panelState[pid];
      if (!state) return;
      
      // Target only elements inside this panel's toolbar
      let panel = document.getElementById(pid);
      if (!panel) return;
      
      panel.querySelectorAll('.color-swatch').forEach(s => {
        s.classList.toggle('active', s.dataset.color === state.currentColor);
      });
      panel.querySelectorAll('.tool-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.tool === state.activeTool);
      });
      panel.querySelectorAll('.tpl-btn').forEach(b => {
        b.classList.toggle('active', b.dataset.template === state.currentTemplate);
      });
    }

    // ----- JUNGLE BACKGROUND (cosmetic, shared) -----
    function buildJungle() {
      let bg = document.getElementById('jungleBg');
      for (let i=0; i<24; i++) {
        let leaf = document.createElement('div');
        leaf.className = 'floating-leaf';
        leaf.textContent = ['üåø','üçÉ','üå¥','üçÄ','üå±'][Math.floor(Math.random()*5)];
        leaf.style.left = Math.random()*100 + '%';
        leaf.style.top = Math.random()*100 + '%';
        leaf.style.animationDelay = Math.random()*10 + 's';
        leaf.style.animationDuration = (15 + Math.random()*20) + 's';
        bg.appendChild(leaf);
      }
    }

    // ----- MODAL: CHOOSE 1 OR 3 PLAYERS (then init layers) -----
    function setupModal() {
      const modal = document.getElementById('playerModal');
      const grid = document.getElementById('canvas-grid');
      const choose1 = document.getElementById('choose1');
      const choose3 = document.getElementById('choose3');

      function startGame(playerCount) {
        modal.classList.add('hidden-modal');
        grid.style.display = 'grid';
        
        if (playerCount === 1) {
          grid.className = 'grid-1';
          document.getElementById('panel2').style.display = 'none';
          document.getElementById('panel3').style.display = 'none';
        } else {
          grid.className = 'grid-3';
          document.getElementById('panel2').style.display = 'flex';
          document.getElementById('panel3').style.display = 'flex';
        }

        // Fresh state for each layer
        PANEL_IDS.forEach(pid => {
          panelState[pid] = createInitialLayerState();
        });

        initPanels();
        buildPanelToolbars();

        window.addEventListener('resize', function() {
          PANEL_IDS.forEach(pid => {
            let p = panels[pid];
            if (p) {
              let idx = PANEL_IDS.indexOf(pid);
              let holder = document.getElementById(HOLDER_IDS[idx]);
              if (holder && holder.clientWidth > 0) {
                let newW = holder.clientWidth;
                let newH = holder.clientHeight;
                p.canvas.width = newW;
                p.canvas.height = newH;
                p.lineCanvas.width = newW;
                p.lineCanvas.height = newH;
                p.width = newW;
                p.height = newH;
                let state = panelState[pid];
                if (state) {
                  buildMasksForPanel(pid, state.currentTemplate);
                }
              }
            }
          });
        });
      }

      choose1.addEventListener('click', () => startGame(1));
      choose3.addEventListener('click', () => startGame(3));
    }

    // ----- DRAWING FUNCTIONS (unchanged from original, but called per layer) -----
    function drawElephant(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+50,180,150,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx,cy-120,130,120,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-150,cy-120,70,100,-0.3,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+150,cy-120,70,100,0.3,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx,cy-60); ctx.quadraticCurveTo(cx-50,cy+50,cx-40,cy+150); ctx.quadraticCurveTo(cx-30,cy+180,cx-10,cy+190); ctx.quadraticCurveTo(cx+10,cy+180,cx+20,cy+150); ctx.quadraticCurveTo(cx+30,cy+50,cx,cy-60); ctx.fill(); ctx.stroke(); for(var i=0;i<4;i++){var lx=cx-100+i*70; ctx.fillRect(lx-25,cy+150,50,120); ctx.strokeRect(lx-25,cy+150,50,120);} ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx-50,cy-140,15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+50,cy-140,15,0,Math.PI*2); ctx.fill(); }
    function drawLion(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; for(var i=0;i<16;i++){var a=(i/16)*Math.PI*2; ctx.beginPath(); ctx.arc(cx+Math.cos(a)*140,cy-80+Math.sin(a)*140,50,0,Math.PI*2); ctx.fill(); ctx.stroke();} ctx.beginPath(); ctx.ellipse(cx,cy-80,110,100,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx,cy+80,140,120,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); for(var i=0;i<4;i++){var lx=cx-90+i*60; ctx.fillRect(lx-20,cy+150,40,110); ctx.strokeRect(lx-20,cy+150,40,110);} ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx-40,cy-90,15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+40,cy-90,15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(cx,cy-50); ctx.lineTo(cx-15,cy-30); ctx.lineTo(cx+15,cy-30); ctx.closePath(); ctx.fill(); }
    function drawMonkey(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+20,120,140,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(cx,cy-120,100,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(cx-90,cy-120,40,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(cx+90,cy-120,40,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx,cy-100,60,70,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-130,cy+50,30,100,-0.3,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+130,cy+50,30,100,0.3,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx-30,cy-110,12,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+30,cy-110,12,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx,cy-90,30,0.2,Math.PI-0.2); ctx.stroke(); }
    function drawParrot(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+30,100,130,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.arc(cx,cy-80,80,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(cx+40,cy-70); ctx.quadraticCurveTo(cx+100,cy-60,cx+90,cy-40); ctx.lineTo(cx+50,cy-50); ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-80,cy+20,50,100,-0.5,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+80,cy+20,50,100,0.5,0,Math.PI*2); ctx.fill(); ctx.stroke(); for(var i=0;i<5;i++){ctx.beginPath(); ctx.ellipse(cx-40+i*20,cy+160,20,80,0,0,Math.PI*2); ctx.fill(); ctx.stroke();} ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx+20,cy-90,12,0,Math.PI*2); ctx.fill(); }
    function drawSnake(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; var bodyW=38, pts=[], segs=80; for(var i=0;i<=segs;i++){var t=i/segs; pts.push({x:cx+Math.sin(t*Math.PI*3)*140, y:cy-180+t*480});} ctx.beginPath(); ctx.moveTo(pts[0].x-bodyW,pts[0].y); for(var i=1;i<=segs;i++){var dx=pts[i].x-pts[i-1].x,dy=pts[i].y-pts[i-1].y,len=Math.sqrt(dx*dx+dy*dy); ctx.lineTo(pts[i].x+(-dy/len)*bodyW, pts[i].y+(dx/len)*bodyW);} ctx.lineTo(pts[segs].x,pts[segs].y+15); for(var i=segs;i>=0;i--){var dx=i>0?pts[i].x-pts[i-1].x:pts[1].x-pts[0].x, dy=i>0?pts[i].y-pts[i-1].y:pts[1].y-pts[0].y, len=Math.sqrt(dx*dx+dy*dy); ctx.lineTo(pts[i].x-(-dy/len)*bodyW, pts[i].y-(dx/len)*bodyW);} ctx.closePath(); ctx.fill(); ctx.stroke(); for(var i=8;i<segs-5;i+=6){ctx.beginPath(); ctx.save(); ctx.translate(pts[i].x,pts[i].y); ctx.moveTo(0,-12); ctx.lineTo(10,0); ctx.lineTo(0,12); ctx.lineTo(-10,0); ctx.closePath(); ctx.restore(); ctx.lineWidth=3; ctx.stroke();} ctx.lineWidth=5; var hx=pts[0].x, hy=pts[0].y-35; ctx.beginPath(); ctx.ellipse(hx,hy,55,45,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(hx-20,hy-8,10,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(hx+20,hy-8,10,0,Math.PI*2); ctx.fill(); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(hx-18,hy-10,3,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(hx+22,hy-10,3,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#333'; ctx.lineWidth=4; ctx.beginPath(); ctx.arc(hx,hy+10,18,0.2,Math.PI-0.2); ctx.stroke(); ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(hx,hy+28); ctx.lineTo(hx-8,hy+42); ctx.moveTo(hx,hy+28); ctx.lineTo(hx+8,hy+42); ctx.stroke(); }
    function drawTiger(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+50,160,130,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx,cy-100,120,110,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); for(var i=0;i<4;i++){var lx=cx-100+i*70; ctx.fillRect(lx-20,cy+130,40,120); ctx.strokeRect(lx-20,cy+130,40,120);} ctx.lineWidth=8; for(var i=0;i<6;i++){ctx.beginPath(); ctx.moveTo(cx-120,cy+20+i*25); ctx.lineTo(cx+120,cy+20+i*25); ctx.stroke();} ctx.lineWidth=5; ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx-40,cy-110,15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+40,cy-110,15,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.moveTo(cx,cy-70); ctx.lineTo(cx-15,cy-50); ctx.lineTo(cx+15,cy-50); ctx.closePath(); ctx.fill(); }
    function drawGiraffe(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+100,140,120,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillRect(cx-30,cy-300,60,400); ctx.strokeRect(cx-30,cy-300,60,400); ctx.beginPath(); ctx.ellipse(cx,cy-330,60,50,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); for(var i=0;i<4;i++){var lx=cx-90+i*60; ctx.fillRect(lx-15,cy+180,30,150); ctx.strokeRect(lx-15,cy+180,30,150);} [[cx-80,cy+80],[cx-40,cy+60],[cx,cy+100],[cx+40,cy+70],[cx+80,cy+90],[cx-20,cy-100],[cx+10,cy-150]].forEach(function(s){ctx.beginPath(); ctx.ellipse(s[0],s[1],25,30,0,0,Math.PI*2); ctx.fill(); ctx.stroke();}); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx+20,cy-340,12,0,Math.PI*2); ctx.fill(); }
    function drawFrog(ctx,w,h) { let cx=w/2, cy=h/2; ctx.strokeStyle='#333'; ctx.lineWidth=5; ctx.fillStyle='white'; ctx.beginPath(); ctx.ellipse(cx,cy+30,130,110,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx,cy-50,120,80,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-60,cy-90,45,50,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+60,cy-90,45,50,0,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx-60,cy-85,20,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(cx+60,cy-85,20,0,Math.PI*2); ctx.fill(); ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(cx,cy-20,60,0.1,Math.PI-0.1); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-110,cy+80,30,60,-0.5,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+110,cy+80,30,60,0.5,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx-130,cy+20,50,80,-0.8,0,Math.PI*2); ctx.fill(); ctx.stroke(); ctx.beginPath(); ctx.ellipse(cx+130,cy+20,50,80,0.8,0,Math.PI*2); ctx.fill(); ctx.stroke(); }

    // ----- START -----
    buildJungle();
    setupModal();
  })();
</script>
</body>
</html>
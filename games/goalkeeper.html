<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Stadium Blocker Pro</title>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-user-select:none;user-select:none}
body{
  font-family:'Segoe UI',Roboto,Helvetica,sans-serif;
  overflow:hidden;background:#0d2d15;touch-action:none;
}
canvas{display:block;position:fixed;inset:0;z-index:0}

/* UI / HUD Styles */
.hud{
  position:fixed;top:14px;left:50%;transform:translateX(-50%);
  display:flex;gap:12px;z-index:100;pointer-events:none;
}
.hud-box{
  background:linear-gradient(180deg, rgba(255,255,255,1) 0%, rgba(240,240,240,0.9) 100%);
  padding:8px 16px;border-radius:12px;
  box-shadow:0 4px 15px rgba(0,0,0,0.4), inset 0 1px 0 rgba(255,255,255,1);
  text-align:center;min-width:75px;border-bottom:3px solid rgba(0,0,0,0.1);
}
.hud-label{font-size:10px;color:#555;text-transform:uppercase;font-weight:800;letter-spacing:1px;margin-bottom:2px;}
.hud-val{font-size:26px;font-weight:800;line-height:1;}
.hud-saves{color:#2E7D32; text-shadow: 0 1px 0 rgba(255,255,255,0.5);}
.hud-missed{color:#D32F2F}
.hud-combo{color:#F57C00}
.hud-time{color:#1565C0}

.combo-popup{
  position:fixed;top:45%;left:50%;transform:translate(-50%,-50%) scale(0);
  font-size:64px;font-weight:900;font-style:italic;color:#FFD700;
  -webkit-text-stroke: 2px #B65C00;
  text-shadow:4px 4px 0px rgba(0,0,0,0.3);
  pointer-events:none;z-index:200;
  white-space:nowrap;
  animation:comboIn .6s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
}
@keyframes comboIn{
  0%{transform:translate(-50%,-50%) scale(0) rotate(-10deg);opacity:0}
  50%{transform:translate(-50%,-50%) scale(1.2) rotate(0deg);opacity:1}
  100%{transform:translate(-50%,-50%) scale(1) rotate(0deg);opacity:0;top:40%;}
}

.start-overlay, .game-over-overlay{
  position:fixed;inset:0;background:rgba(0,0,0,.85);
  display:flex;flex-direction:column;align-items:center;justify-content:center;
  z-index:500;backdrop-filter:blur(8px);
}
.start-overlay.hidden{display:none}
.game-over-overlay{display:none}
.game-over-overlay.show{display:flex}

.start-title{
  font-size:clamp(40px,8vw,64px);font-weight:900;color:#fff;
  margin-bottom:10px;text-transform:uppercase;font-style:italic;
  text-shadow:0 4px 0 #2E7D32, 0 8px 20px rgba(0,0,0,0.5);
}
.start-sub{font-size:18px;color:#ccc;margin-bottom:40px;text-align:center;max-width:400px;line-height:1.4}

.btn-primary{
  padding:16px 48px;font-size:24px;font-weight:800;text-transform:uppercase;
  background:linear-gradient(to bottom, #4CAF50, #2E7D32);
  color:white;border:none;border-radius:50px;cursor:pointer;
  box-shadow:0 6px 0 #1B5E20, 0 15px 30px rgba(0,0,0,0.4);
  transition:transform .1s, box-shadow .1s;
  text-shadow: 0 2px 2px rgba(0,0,0,0.3);
}
.btn-primary:active{transform:translateY(4px);box-shadow:0 2px 0 #1B5E20, 0 5px 15px rgba(0,0,0,0.4);}

.go-box{
  background:#fff;padding:40px;border-radius:20px;text-align:center;
  box-shadow:0 0 50px rgba(0,0,0,0.5);max-width:90%;width:400px;
}
.go-box h2{font-size:36px;color:#333;margin-bottom:10px;font-weight:900;}
.stats-row{display:flex;justify-content:center;gap:20px;margin-bottom:30px;font-size:20px;color:#555;}
.btn-group{display:flex;justify-content:center;gap:10px;}
.btn-small{
  padding:12px 24px;font-size:16px;font-weight:700;border-radius:30px;border:none;color:#fff;cursor:pointer;
  transition:transform .1s;
}
.btn-small:active{transform:scale(0.95);}
.btn-restart{background:linear-gradient(to bottom, #4CAF50, #2E7D32); box-shadow:0 4px 0 #1B5E20;}
.btn-menu{background:linear-gradient(to bottom, #2196F3, #1565C0); box-shadow:0 4px 0 #0D47A1;}

/* EXIT BUTTON - LEFT MIDDLE */
.side-bar{
  position:fixed;
  top:50%;
  left:15px;
  transform:translateY(-50%);
  z-index:100;
}
.btn-back{
  display:block;
  padding:12px 12px;
  width: 50px;
  height: 50px;
  font-size:10px;
  font-weight:700;
  text-transform:uppercase;
  background:rgba(255,255,255,0.2);
  color:white;
  border:2px solid rgba(255,255,255,0.4);
  border-radius:50%;
  backdrop-filter:blur(4px);
  text-align: center;
  line-height: 1.1;
  display:flex; align-items:center; justify-content:center;
  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
  cursor:pointer;
}

.tap-ring{
  position:fixed;pointer-events:none;z-index:150;
  border:4px solid #fff;border-radius:50%;
  box-shadow: 0 0 15px #fff, inset 0 0 10px #fff;
  transform:translate(-50%,-50%) scale(0);
  animation:tapRing .4s ease-out forwards;
}
@keyframes tapRing{
  0%{width:0;height:0;opacity:1;border-width:6px;}
  100%{width:120px;height:120px;opacity:0;border-width:0px;}
}
</style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div class="hud" id="hud" style="display:none">
  <div class="hud-box">
    <div class="hud-label">Saves</div>
    <div class="hud-val hud-saves" id="savesVal">0</div>
  </div>
  <div class="hud-box">
    <div class="hud-label">Missed</div>
    <div class="hud-val hud-missed" id="missedVal">0</div>
  </div>
  <div class="hud-box">
    <div class="hud-label">Combo</div>
    <div class="hud-val hud-combo" id="comboVal">0</div>
  </div>
  <div class="hud-box">
    <div class="hud-label">Time</div>
    <div class="hud-val hud-time" id="timeVal">60</div>
  </div>
</div>

<div class="start-overlay" id="startOverlay">
  <div class="start-title">Super Keeper</div>
  <div class="start-sub">Block the shots coming from down field!</div>
  <button class="btn-primary" id="startBtn">KICK OFF</button>
</div>

<div class="game-over-overlay" id="gameOverOverlay">
  <div class="go-box">
    <h2>FULL TIME</h2>
    <div class="stats-row">
       <div><span style="display:block;font-size:12px;color:#999;font-weight:700">SAVES</span><span id="endSaves" style="color:#2E7D32;font-weight:800">0</span></div>
       <div><span style="display:block;font-size:12px;color:#999;font-weight:700">MISSED</span><span id="endMissed" style="color:#D32F2F;font-weight:800">0</span></div>
    </div>
    <div class="btn-group">
      <button class="btn-small btn-restart" id="restartBtn">REMATCH</button>
      <button class="btn-small btn-menu" id="goMenuBtn">MENU</button>
    </div>
  </div>
</div>

<div class="side-bar">
  <button class="btn-back" id="backBtn">EXIT</button>
</div>

<script>
/**
 * Audio System (Procedural)
 */
const AudioSys = {
  ctx: null,
  init: function() {
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AudioContext();
  },
  playThud: function() {
    if(!this.ctx) this.init();
    if(this.ctx.state === 'suspended') this.ctx.resume();
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    // Kick drum synthesis
    osc.frequency.setValueAtTime(150, t);
    osc.frequency.exponentialRampToValueAtTime(0.01, t + 0.5);
    
    filter.type = "lowpass";
    filter.frequency.setValueAtTime(300, t);

    gain.gain.setValueAtTime(0.8, t);
    gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
    
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    
    osc.start(t);
    osc.stop(t + 0.5);
  },
  playCheer: function(intensity) {
    if(!this.ctx) return;
    const t = this.ctx.currentTime;
    const bufferSize = this.ctx.sampleRate * 1.5; 
    const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * 0.5; // White noise
    }

    const noise = this.ctx.createBufferSource();
    noise.buffer = buffer;
    
    const filter = this.ctx.createBiquadFilter();
    filter.type = "lowpass";
    filter.frequency.value = 800 + (intensity * 200);
    
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.1 + (intensity * 0.05), t);
    gain.gain.linearRampToValueAtTime(0, t + 1.5);
    
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.ctx.destination);
    noise.start(t);
  },
  playWhistle: function() {
    if(!this.ctx) return;
    const t = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    // Whistle trill
    osc.frequency.setValueAtTime(2500, t);
    osc.frequency.linearRampToValueAtTime(2000, t + 0.1);
    osc.frequency.linearRampToValueAtTime(2500, t + 0.2);
    
    gain.gain.setValueAtTime(0.3, t);
    gain.gain.linearRampToValueAtTime(0, t + 0.8);
    
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(t);
    osc.stop(t + 0.8);
  }
};

/**
 * Game Logic
 */
var cvs = document.getElementById('gameCanvas');
var ctx = cvs.getContext('2d');
var W, H;

var saves = 0, missed = 0, combo = 0, timeLeft = 60;
var gameActive = false, balls = [], particles = [];
var difficulty = 1, spawnInterval = 1600;
var lastSpawn = 0, clockTimer = null;
var goalY, goalH;

// Pre-calculate visuals
var grassPattern;

function resize() {
  W = cvs.width = window.innerWidth;
  H = cvs.height = window.innerHeight;
  goalY = H * 0.70; // Slightly higher start for bigger goal
  // INCREASED GOAL HEIGHT: Was 0.15, now 0.25 (Tall Net)
  goalH = H * 0.25; 
  createGrassPattern();
}

function createGrassPattern() {
    // Create a procedural grass texture
    var pCanvas = document.createElement('canvas');
    pCanvas.width = 50; pCanvas.height = 50;
    var pCtx = pCanvas.getContext('2d');
    pCtx.fillStyle = '#2E7D32'; // Base dark green
    pCtx.fillRect(0,0,50,50);
    
    // Add noise
    for(let i=0; i<400; i++) {
        pCtx.fillStyle = Math.random() > 0.5 ? '#388E3C' : '#1B5E20';
        pCtx.fillRect(Math.random()*50, Math.random()*50, 2, 2);
    }
    grassPattern = ctx.createPattern(pCanvas, 'repeat');
}

window.addEventListener('resize', resize);
resize();

// Enhanced Color Palette
var BALL_SKINS = [
    {main: '#ECEFF1', patch: '#263238'}, // Classic
    {main: '#FFEB3B', patch: '#0D47A1'}, // Brazil
    {main: '#ffffff', patch: '#D32F2F'}, // Red/White
    {main: '#212121', patch: '#FFD700'}, // Gold/Black
    {main: '#F44336', patch: '#ffffff'}  // Red
];

function Ball() {
  // Spawn logic
  // 0: Center Shot (Horizon), 1: Left Flank, 2: Right Flank, 3: High Ball
  var spawnType = Math.random();
  
  if (spawnType < 0.4) { 
    // CENTER SHOT (40% chance)
    // Spawns near the horizon line (H*0.4) in the middle
    this.x = (W/2) + (Math.random() - 0.5) * (W * 0.2);
    this.y = H * 0.35; 
  } else if (spawnType < 0.7) { 
    // SKY/TOP (30% chance)
    this.x = Math.random() * W;
    this.y = -60;
  } else if (spawnType < 0.85) { 
    // LEFT
    this.x = -60;
    this.y = H * 0.2 + Math.random() * H * 0.2;
  } else { 
    // RIGHT
    this.x = W + 60;
    this.y = H * 0.2 + Math.random() * H * 0.2;
  }
  
  // Target logic (Goal area)
  var targetX = W * 0.2 + Math.random() * (W * 0.6);
  var targetY = goalY + Math.random() * (goalH * 0.8);
  
  var dx = targetX - this.x, dy = targetY - this.y;
  var dist = Math.hypot(dx, dy);
  
  // SLOWED DOWN SPEED
  // Was: 2 + diff*0.4
  // Now: 1.2 + diff*0.2 (Much slower)
  var speed = 1.2 + difficulty * 0.2 + Math.random() * 0.5;
  
  this.vx = (dx / dist) * speed;
  this.vy = (dy / dist) * speed;
  
  // Base Radius
  this.r = 32 + Math.random() * 12; 
  
  this.skin = BALL_SKINS[Math.floor(Math.random() * BALL_SKINS.length)];
  this.rotation = Math.random() * Math.PI * 2;
  this.rotSpeed = (Math.random() - 0.5) * 0.2;
  this.alive = true;
  this.blocked = false;
  this.alpha = 1;
  this.scale = 0.5; // Start small if far away
}

Ball.prototype.update = function() {
  if (this.blocked) {
    this.vy += 0.5; // Gravity
    this.x += this.vx;
    this.y += this.vy;
    this.rotation += this.rotSpeed * 2;
    this.scale -= 0.02;
    if (this.scale <= 0) this.alive = false;
  } else {
    this.x += this.vx;
    this.y += this.vy;
    
    // Fake 3D scaling as it gets closer
    // Remap Y from spawn (horizon) to Goal (goalY) to scale 
    let minY = H * 0.3; 
    let maxY = goalY + 60;
    let progress = (this.y - minY) / (maxY - minY);
    // Clamp progress
    if(progress < 0) progress = 0;
    
    this.scale = 0.5 + (progress * 0.7); // Grow from 0.5 to 1.2

    if (this.y >= goalY + goalH * 0.8) { // Hit near bottom of goal
      this.alive = false;
      missed++;
      combo = 0;
      document.getElementById('missedVal').textContent = missed;
      document.getElementById('comboVal').textContent = combo;
      spawnMissParticles(this.x, this.y);
      if (missed >= 10) endGame();
    }
  }
  this.rotation += this.rotSpeed;
};

Ball.prototype.draw = function() {
  ctx.save();
  ctx.translate(this.x, this.y);
  ctx.scale(this.scale, this.scale);
  ctx.rotate(this.rotation);

  // 1. Shadow (underneath)
  if(!this.blocked) {
      ctx.save();
      ctx.rotate(-this.rotation); // Undo rotation for shadow
      ctx.fillStyle = 'rgba(0,0,0,0.3)';
      ctx.beginPath();
      // Shadow size relative to scale (fake height)
      ctx.ellipse(5, this.r + 5, this.r * 0.8, this.r * 0.4, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
  }

  // 2. Base Sphere (Radial Gradient)
  var grad = ctx.createRadialGradient(-this.r*0.3, -this.r*0.3, this.r*0.2, 0, 0, this.r);
  grad.addColorStop(0, this.skin.main);
  grad.addColorStop(1, shadeColor(this.skin.main, -40)); // Darker rim
  
  ctx.beginPath();
  ctx.arc(0, 0, this.r, 0, Math.PI * 2);
  ctx.fillStyle = grad;
  ctx.fill();

  // 3. Patches (Pentagon pattern to show rotation)
  ctx.fillStyle = this.skin.patch;
  
  // Draw center pentagon
  drawPoly(ctx, 0, 0, this.r * 0.45, 5);
  
  // Draw side pentagons (wrapping effect)
  for(let i=0; i<5; i++) {
      let angle = (i * 72) * Math.PI/180;
      let dist = this.r * 0.85;
      drawPoly(ctx, Math.cos(angle)*dist, Math.sin(angle)*dist, this.r * 0.3, 5);
  }

  // 4. Gloss/Highlight
  ctx.rotate(-this.rotation); // Keep highlight static relative to light source
  ctx.beginPath();
  ctx.ellipse(-this.r*0.3, -this.r*0.35, this.r*0.3, this.r*0.2, Math.PI/4, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.35)';
  ctx.fill();

  ctx.restore();
};

Ball.prototype.contains = function(px, py) {
  // Hitbox slightly larger than visual radius for better feel
  return Math.hypot(px - this.x, py - this.y) < (this.r * this.scale) + 15;
};

// Helper for pentagons
function drawPoly(ctx, x, y, r, sides) {
    ctx.beginPath();
    for (var i = 0; i < sides; i++) {
        var angle = (i * 2 * Math.PI / sides) - Math.PI/2;
        var px = x + r * Math.cos(angle);
        var py = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fill();
}

// Helper to darken colors
function shadeColor(color, percent) {
    var R = parseInt(color.substring(1,3),16);
    var G = parseInt(color.substring(3,5),16);
    var B = parseInt(color.substring(5,7),16);
    R = parseInt(R * (100 + percent) / 100);
    G = parseInt(G * (100 + percent) / 100);
    B = parseInt(B * (100 + percent) / 100);
    R = (R<255)?R:255; G = (G<255)?G:255; B = (B<255)?B:255; 
    return "#"+((R.toString(16).length==1)?"0"+R.toString(16):R.toString(16))+((G.toString(16).length==1)?"0"+G.toString(16):G.toString(16))+((B.toString(16).length==1)?"0"+B.toString(16):B.toString(16));
}

// Particle System
function Particle(x, y, color, type) {
  this.x = x; this.y = y; this.color = color;
  this.type = type; // 0=confetti, 1=spark
  const angle = Math.random() * Math.PI * 2;
  const sp = 2 + Math.random() * 8;
  this.vx = Math.cos(angle) * sp;
  this.vy = Math.sin(angle) * sp;
  this.r = Math.random() * 4 + 2;
  this.life = 1;
  this.decay = 0.02 + Math.random() * 0.02;
  this.gravity = 0.2;
}
Particle.prototype.update = function() {
  this.vy += this.gravity;
  this.vx *= 0.95; 
  this.x += this.vx; this.y += this.vy;
  this.life -= this.decay;
};
Particle.prototype.draw = function() {
  ctx.globalAlpha = Math.max(0, this.life);
  ctx.fillStyle = this.color;
  if(this.type === 0) {
      ctx.fillRect(this.x, this.y, this.r, this.r);
  } else {
      ctx.beginPath(); ctx.arc(this.x, this.y, this.r/2, 0, Math.PI*2); ctx.fill();
  }
  ctx.globalAlpha = 1;
};

function spawnSaveParticles(x, y, skin) {
  for (var i = 0; i < 15; i++) {
    particles.push(new Particle(x, y, skin.patch, 0));
    particles.push(new Particle(x, y, '#fff', 1));
  }
}
function spawnMissParticles(x, y) {
  for (var i = 0; i < 10; i++) {
    particles.push(new Particle(x, y, '#D32F2F', 1));
  }
}

function handleTap(x, y) {
  if (!gameActive) return;
  
  // Visual Feedback
  var ring = document.createElement('div');
  ring.className = 'tap-ring';
  ring.style.left = x + 'px'; ring.style.top = y + 'px';
  document.body.appendChild(ring);
  setTimeout(() => ring.remove(), 500);

  var hit = false;
  // Check balls (iterate backwards to hit top one first)
  for (var i = balls.length - 1; i >= 0; i--) {
    var b = balls[i];
    if (!b.blocked && b.alive && b.contains(x, y)) {
      b.blocked = true;
      // Physics bounce
      b.vx = (x - W/2) * 0.05 + (Math.random()-0.5)*5;
      b.vy = -10 - Math.random() * 5;
      
      saves++;
      combo++;
      hit = true;
      
      spawnSaveParticles(b.x, b.y, b.skin);
      
      // Update HUD
      document.getElementById('savesVal').textContent = saves;
      document.getElementById('comboVal').textContent = combo;
      
      if (combo > 0 && combo % 5 === 0) {
          showCombo();
          AudioSys.playCheer(Math.min(combo/20, 1));
      }
      
      AudioSys.playThud();
      break;
    }
  }
  if (!hit) { 
      combo = 0; 
      document.getElementById('comboVal').textContent = 0; 
  }
}

function showCombo() {
  var msgs = ['SUPER!', 'MEGA!', 'ULTRA!', 'LEGEND!', 'GODLIKE!'];
  var el = document.createElement('div');
  el.className = 'combo-popup';
  el.textContent = msgs[Math.min(Math.floor(combo / 5) - 1, msgs.length - 1)] + ' ' + combo + 'x';
  document.body.appendChild(el);
  setTimeout(function() { el.remove(); }, 800);
}

function drawStadium() {
  // 1. SKY (Top 40%) - REPLACED STADIUM
  var gradSky = ctx.createLinearGradient(0, 0, 0, H*0.4);
  gradSky.addColorStop(0, '#29B6F6'); // Light Blue
  gradSky.addColorStop(1, '#B3E5FC'); // Very Light Blue/White at horizon
  ctx.fillStyle = gradSky;
  ctx.fillRect(0, 0, W, H * 0.4);
  
  // Clouds (Simple)
  ctx.fillStyle = 'rgba(255,255,255,0.4)';
  ctx.beginPath();
  ctx.arc(W*0.2, H*0.1, 40, 0, Math.PI*2);
  ctx.arc(W*0.25, H*0.12, 50, 0, Math.PI*2);
  ctx.fill();

  ctx.beginPath();
  ctx.arc(W*0.8, H*0.15, 60, 0, Math.PI*2);
  ctx.arc(W*0.7, H*0.12, 45, 0, Math.PI*2);
  ctx.fill();

  // 2. Ad Boards (Horizon Line)
  var adY = H * 0.4;
  var adH = 20;
  ctx.fillStyle = '#C62828'; // Red board
  ctx.fillRect(0, adY, W, adH);
  ctx.fillStyle = '#fff';
  ctx.font = '10px Arial';
  for(let i=0; i<W; i+=150) {
      ctx.fillText("BLOCKER PRO", i + 20, adY + 14);
  }

  // 3. Grass Field (Perspective Striped)
  var fieldY = adY + adH;
  // Draw base grass
  ctx.fillStyle = grassPattern || '#2E7D32'; 
  ctx.fillRect(0, fieldY, W, H - fieldY);
  
  // Stripes
  ctx.fillStyle = 'rgba(0,0,0,0.1)';
  var stripeH = (H - fieldY) / 10;
  for(let i=0; i<10; i++) {
      if(i%2==0) ctx.fillRect(0, fieldY + i*stripeH, W, stripeH);
  }

  // 4. White Lines (Penalty Box)
  ctx.strokeStyle = 'rgba(255,255,255,0.7)';
  ctx.lineWidth = 4;
  ctx.beginPath();
  
  // Center circle arc at top of field
  ctx.arc(W/2, fieldY - 50, 80, 0, Math.PI); 
  ctx.stroke();

  // Penalty Box
  var boxW = W * 0.6;
  var boxH = (H - fieldY) * 0.7;
  var boxX = (W - boxW) / 2;
  
  ctx.beginPath();
  ctx.moveTo(boxX, fieldY);
  ctx.lineTo(boxX, fieldY + boxH);
  ctx.lineTo(boxX + boxW, fieldY + boxH);
  ctx.lineTo(boxX + boxW, fieldY);
  ctx.stroke();

  // 5. Goal Structure (Bottom)
  var gLeft = W * 0.1, gRight = W * 0.9;
  var gTop = goalY, gBot = goalY + goalH;
  
  // Net (Back)
  ctx.fillStyle = 'rgba(200,200,200,0.15)';
  ctx.fillRect(gLeft+10, gTop+10, (gRight-gLeft)-20, goalH-10);
  
  // Net Lines
  ctx.strokeStyle = 'rgba(255,255,255,0.15)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  for(let x=gLeft; x<=gRight; x+=15) { ctx.moveTo(x, gTop); ctx.lineTo(x, gBot); }
  for(let y=gTop; y<=gBot; y+=15) { ctx.moveTo(gLeft, y); ctx.lineTo(gRight, y); }
  ctx.stroke();

  // Posts (Gradient to look 3D)
  var postGrad = ctx.createLinearGradient(gLeft, 0, gLeft+10, 0);
  postGrad.addColorStop(0, '#ddd'); postGrad.addColorStop(0.5, '#fff'); postGrad.addColorStop(1, '#999');
  
  ctx.fillStyle = postGrad;
  // Left Post
  ctx.fillRect(gLeft, gTop, 8, goalH);
  // Right Post
  ctx.fillRect(gRight-8, gTop, 8, goalH);
  // Crossbar
  ctx.fillRect(gLeft, gTop, gRight-gLeft, 8);
}

function gameLoop() {
  ctx.clearRect(0, 0, W, H);
  drawStadium();

  if (gameActive) {
    var now = Date.now();
    if (now - lastSpawn > spawnInterval) {
      balls.push(new Ball());
      lastSpawn = now;
      if (saves > 0 && saves % 5 === 0 && difficulty < 10) {
        difficulty++;
        spawnInterval = Math.max(800, spawnInterval - 100);
      }
    }
  }

  // Sort balls by Y so lower balls draw on top of higher ones (pseudo 3D)
  balls.sort((a,b) => a.y - b.y);

  for (var i = balls.length - 1; i >= 0; i--) {
    balls[i].update();
    balls[i].draw();
    if (!balls[i].alive) balls.splice(i, 1);
  }
  for (var i = particles.length - 1; i >= 0; i--) {
    particles[i].update();
    particles[i].draw();
    if (particles[i].life <= 0) particles.splice(i, 1);
  }

  requestAnimationFrame(gameLoop);
}

function startGame() {
  AudioSys.init();
  document.getElementById('startOverlay').classList.add('hidden');
  document.getElementById('hud').style.display = 'flex';
  gameActive = true;
  lastSpawn = Date.now();
  clockTimer = setInterval(function() {
    if (!gameActive) { clearInterval(clockTimer); return; }
    timeLeft--;
    document.getElementById('timeVal').textContent = timeLeft;
    if (timeLeft <= 0) { clearInterval(clockTimer); endGame(); }
  }, 1000);
}

function endGame() {
  gameActive = false;
  AudioSys.playWhistle();
  if (clockTimer) clearInterval(clockTimer);
  document.getElementById('endSaves').textContent = saves;
  document.getElementById('endMissed').textContent = missed;
  document.getElementById('gameOverOverlay').classList.add('show');
}

function restartGame() {
  saves = 0; missed = 0; combo = 0; timeLeft = 60;
  difficulty = 1; spawnInterval = 1600;
  balls = []; particles = [];
  document.getElementById('savesVal').textContent = '0';
  document.getElementById('missedVal').textContent = '0';
  document.getElementById('comboVal').textContent = '0';
  document.getElementById('timeVal').textContent = '60';
  document.getElementById('gameOverOverlay').classList.remove('show');
  gameActive = true;
  lastSpawn = Date.now();
  clockTimer = setInterval(function() {
    if (!gameActive) { clearInterval(clockTimer); return; }
    timeLeft--;
    document.getElementById('timeVal').textContent = timeLeft;
    if (timeLeft <= 0) { clearInterval(clockTimer); endGame(); }
  }, 1000);
}

cvs.addEventListener('pointerdown', function(e) {
  e.preventDefault();
  handleTap(e.clientX, e.clientY);
});

// Input handling helpers
function addTouchBtn(id, fn) {
  var el = document.getElementById(id);
  if (!el) return;
  el.addEventListener('click', fn);
  el.addEventListener('touchend', function(e) { 
      e.preventDefault(); e.stopPropagation(); fn(); 
  });
}

addTouchBtn('startBtn', startGame);
addTouchBtn('restartBtn', restartGame);
addTouchBtn('goMenuBtn', function() { location.href = '../index.html'; });
addTouchBtn('backBtn', function() { location.href = '../index.html'; });

// Start
gameLoop();

</script>
</body>
</html>